{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to OpsBox Documentation","text":"<p>OpsBox is a powerful and flexible infrastructure management tool designed to help you automate, monitor, and optimize your cloud resources. This documentation provides comprehensive guides, tutorials, and references to help you get the most out of OpsBox.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>New to OpsBox? Start here to set up your environment and learn the basics.</p> <ul> <li>Installation Guide</li> <li>Running OpsBox</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Understand the core concepts and components of OpsBox.</p> <ul> <li>Plugin Overview</li> <li>Available Plugins</li> </ul>"},{"location":"#developing-plugins","title":"Developing Plugins","text":"<p>Learn how to extend OpsBox by developing your own plugins.</p> <ul> <li>Development Basics</li> <li>Making Handlers</li> <li>Making Providers</li> <li>Making Outputs</li> <li>Making Checks</li> </ul>"},{"location":"#testing","title":"Testing","text":"<p>Ensure your plugins and configurations work as expected with our testing guides.</p> <ul> <li>Testing OpsBox</li> <li>Testing Handlers</li> <li>Testing General Plugins</li> <li>Testing Rego Plugins</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Want to contribute to OpsBox? Check out our guidelines.</p> <ul> <li>Contributing Guide</li> </ul>"},{"location":"#community-plugins","title":"Community Plugins","text":"<p>Explore plugins developed by us for the OpsBox community.</p> <ul> <li>Community Plugins Home</li> </ul> <p>Thank you for using OpsBox! We hope this documentation helps you achieve your infrastructure management goals.</p>"},{"location":"core/","title":"Welcome to OpsBox Core","text":"<p>Welcome to Opsbox Core, The core of your AI-powered infrastructure monitoring.</p> <p>To get started, follow the instructions in \"Getting Started\".</p>"},{"location":"core/contributing/","title":"Contributing to Opsbox","text":"<p>Thank you for your interest in contributing to Opsbox! </p> <p>We welcome contributions in the form of bug reports, feature requests, documentation improvements, new rego checks, and code changes. To ensure a smooth and efficient collaboration process, please follow these guidelines.</p>"},{"location":"core/contributing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Code of Conduct</li> <li>Getting Started</li> <li>Coding Standards</li> <li>Branching Strategy</li> <li>Precommit Hooks</li> <li>Submitting Changes</li> </ol>"},{"location":"core/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in the Opsbox project, you agree to abide by the following guidelines:</p> <ol> <li>Respectful Interaction: Treat all participants with respect. Consider different viewpoints and experiences.</li> <li>Inclusivity: Promote a diverse and inclusive environment.</li> <li>Effective Communication: Use clear and constructive language. Be open to feedback and collaborate effectively.</li> <li>Issue Reporting: Report any unacceptable behavior to the project maintainers.</li> </ol>"},{"location":"core/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork to your local machine:    <pre><code>git clone https://github.com/sudoersllc/OpsBox.git\ncd opsbox\n</code></pre></li> <li>Install UV for dependency management:    <pre><code>pipx install uv\n</code></pre></li> <li>Install the project dependencies:    <pre><code>uv sync\n</code></pre></li> <li>Install precommit hooks:    <pre><code>uv run pre-commit install\n</code></pre></li> </ol>"},{"location":"core/contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li> <p>Docstrings: All classes and functions must have docstrings in Google style. This ensures consistency and helps others understand your code.   <pre><code>def example_function(param1: int, param2: str) -&gt; bool:\n    \"\"\"\n    Example function that demonstrates Google style docstrings.\n\n    Args:\n        param1 (int): The first parameter.\n        param2 (str): The second parameter.\n\n    Returns:\n        bool: The return value. True for success, False otherwise.\n    \"\"\"\n    return True\n</code></pre></p> </li> <li> <p>Formatting and Linting: We use <code>ruff</code> for formatting and linting. Make sure to run <code>ruff</code> before submitting your changes.   <pre><code>uv run ruff .\n</code></pre></p> </li> </ul>"},{"location":"core/contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li> <p>Create a new branch for each task you work on. This helps in managing and reviewing changes effectively.   <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Branch names should be descriptive and follow the convention: <code>feature/your-feature-name</code>, <code>bugfix/your-bugfix-name</code>, etc.</p> </li> </ul>"},{"location":"core/contributing/#precommit-hooks","title":"Precommit Hooks","text":"<p>We use precommit hooks to ensure code quality and consistency. Make sure to install and use them: <pre><code>uv run pre-commit install\n</code></pre> These hooks will automatically run checks and formatting tools before you commit changes.</p>"},{"location":"core/contributing/#submitting-changes","title":"Submitting Changes","text":"<ol> <li>Ensure your code follows the coding standards mentioned above.</li> <li>Run all tests to make sure nothing is broken.</li> <li>Commit your changes with a clear and concise commit message:    <pre><code>git add .\ngit commit -m \"Add feature/fix for ...\"\n</code></pre></li> <li>Push your branch to GitHub:    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Open a pull request on GitHub and describe your changes in detail.</li> </ol> <p>Thank you for contributing to Opsbox!</p>"},{"location":"core/getting_started/installation/","title":"Installation","text":"<p>Ready to dive in? Let's get you set up!</p>"},{"location":"core/getting_started/installation/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following installed on your machine:</p> <ul> <li>Python == 3.11</li> <li>UV for dependency management</li> <li>Docker for running OPA server</li> </ul>"},{"location":"core/getting_started/installation/#verifying-installations","title":"Verifying Installations","text":"<p>To verify that Python is installed, run the following command:</p> <pre><code>python --version\nuv --version\ndocker --version\n</code></pre> <p>Installing Python:</p> <p>Visit the official Python website and download the latest version of Python for your operating system.</p> <p>Installing UV</p> <p>UV can be installed in various ways. The recommended method is to use the installer script:</p> <p>For Linux/Mac</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>For Windows <pre><code>powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre></p>"},{"location":"core/getting_started/installation/#installing-opsbox-through-pypi","title":"Installing Opsbox Through PyPI","text":"<p>Simply run <code>pip install opsbox</code> to install the minimal set of opsbox tools.</p> <p>If using UV, initilize your project using <code>uv init</code>.</p> <p>then <code>uv add opsbox</code></p> <p>Note: If you want to install AWS plugins, use the aws extras group, <code>opsbox[aws]</code></p>"},{"location":"core/getting_started/installation/#installing-opsbox-through-github","title":"Installing Opsbox Through Github","text":"<ol> <li> <p>Clone the Repository</p> <pre><code>git clone https://github.com/sudoersllc/Opsbox.git\ncd Opsbox\n</code></pre> </li> <li> <p>Install with uv</p> <p>We use [<code>uv</code>] for managing dependencies. If you don't have it installed, you can get it via pip:</p> <pre><code>pip install uv\n</code></pre> <p>Now, let's install Opsbox:</p> <pre><code>uv sync\n</code></pre> <p>This command will install all required dependencies specified in <code>pyproject.toml</code>.</p> </li> </ol>"},{"location":"core/getting_started/installation/#using-rego-plugins","title":"Using Rego Plugins","text":"<p>Open Policy Agent (OPA) is an open-source policy engine that enables organizations to implement policy as code across diverse environments. Its policy language, Rego, allows users to define rules that dictate system and application behavior.</p> <p>We use rego code to gather details about connected systems, alongside an Open Policy Agent (OPA) server, then format it for consumption by a language model.</p>"},{"location":"core/getting_started/installation/#create-a-opa-policy-docker-image","title":"Create a OPA Policy docker image","text":"<p>To run OpsBox with rego plugins, you'll need an OPA server. This is because OpsBox uses OPA to enforce policies on all resources that are being managed.</p> <p>if you don't have OPA installed on your machine, or you dont have a running OPA instance, you can create a docker image for OPA.</p> <p>Start by installing docker.</p> <p>Create a dockerfile and add the following code: <pre><code>    # Use the official OPA image\n    FROM openpolicyagent/opa:latest\n\n    # Expose OPA's default port\n    EXPOSE 8181\n\n    # Run OPA with the specified policy file\n    CMD [\"run\", \"--server\", \"--addr\", \"0.0.0.0:8181\"]\n</code></pre></p> <p>Navigate to the directory and Build the Docker image: <pre><code>    docker build -t opa-server .\n</code></pre> or you can also follow the offical OPA documentation to create the engine: OPA Documentation</p> <p>Finally, run the OPA server as follows: <pre><code>    docker run -d -p 8181:8181 --name opa-server opa-server\n</code></pre></p> <p>Or the docker image can be found here (https://hub.docker.com/r/openpolicyagent/opa/)</p> <pre><code>    docker run -d -p 8181:8181 --name opa openpolicyagent/opa run --server --addr=0.0.0.0:8181*\n</code></pre>"},{"location":"core/getting_started/running/","title":"Running OpsBox","text":""},{"location":"core/getting_started/running/#running-opsbox","title":"Running OpsBox","text":"<p>To run Opsbox from a venv, simply call the python module <code>opsbox</code>.</p> <p>With uv, this looks like <code>uv run opsbox ...</code> Without, it looks like <code>python -m opsbox ...</code></p> <p>When run outside of a venv, use the <code>main.py</code> script found in <code>core</code>.</p> <p>An example call to opsbox must at least include the <code>modules</code> argument, like so:</p> <pre><code>uv run opsbox --modules your_input-your_optional_assistant-your_output --opa_url http://your-opa-url \n</code></pre> <p>A recommended command to start is stray_ebs</p> <pre><code>uv run opsbox --modules stray_ebs-cli_out --opa_url http://localhost:8181/ --aws_access_key_id {YOUR_ACCESS_KEY_ID} --aws_secret_access_key {YOUR_SECRET_ACCESS_KEY} --aws_region us-east-1\n</code></pre> <p>or, if not using UV:</p> <pre><code>python -m opsbox --modules your_input-your_optional_assistant-your_output --opa_url http://your-opa-url \n</code></pre> <p><pre><code>python -m opsbox --modules stray_ebs-cli_out --opa_url http://localhost:8181/ --aws_access_key_id {YOUR_ACCESS_KEY_ID} --aws_secret_access_key {YOUR_SECRET_ACCESS_KEY} --aws_region us-east-1\n</code></pre> Make sure you have any of the prerequisite packages for the plugins you want to use!</p>"},{"location":"core/getting_started/running/#configuration","title":"Configuration","text":""},{"location":"core/getting_started/running/#modules","title":"Modules","text":"<p>Opsbox uses a series of modules specified at runtime to analyze different environments. These modules have their own arguments and required settings that will be looked for upon startup, and must specified as a pipeline in the following format:</p> <pre><code>input_1,input_2-assistant_1-assistant_2-output_1,output_2\n</code></pre> <p>Where:</p> <pre><code>- The first arguments are the input plugins we want to use, seperated with a comma\n- The middle arguments are the assistants we want to use, seperated by a hyphen\n- The last arguments are the outputs we want to use, sepereated by a comma\n</code></pre> <p>For instance, if we wanted to check for stray EBS volumes and output the results to the main after running through a cost assistant, we would need to use the following pipeline:</p> <pre><code>stray_ebs-cost_savings-main_out\n</code></pre> <p>Of course, the assistant and the module the check uses will require additional parameters, such as an OpenAI key. Keep reading to figure out how to set these up.</p>"},{"location":"core/getting_started/running/#local-plugin-development","title":"Local plugin development","text":"<p>To develop and use plugins locally, simply point opsbox to the directory where your plugins are located using the <code>plugin_dir</code> configuration argument.</p> <p>As long as the plugins you specify are found in this directory, opsbox will use them instead of the virtual environment-installed packages.</p> <p><code>uv run opsbox ... --plugin_dir ./plugins</code></p>"},{"location":"core/getting_started/running/#open-policy-agent-rego-only","title":"Open Policy Agent (Rego Only)","text":"<p>Opsbox uses OPA to upload and execute rego checks.</p> <p>Open Policy Agent (OPA) is an open-source policy engine that allows organizations to enforce policies as code across various environments. Its policy language, Rego, enables users to define rules that govern the behavior of systems and applications.</p> <p>We use rego check plugins as ways to get information on various systems and see how they function</p> <p>Before running any rego-based input plugins, ensure you have access to an OPA (Open Policy Agent) instance. For local testing, you can run a test OPA instance as follows:</p> <p>You can run a local test OPA instance by following the steps in installation and running the following command:</p> <pre><code>    docker run -d -p 8181:8181 opa-policy\n</code></pre> <p>To do this, one required configuration parameters is needed:</p> <ul> <li><code>opa_url</code> : URL to upload rego policies to</li> </ul> <p>If you created a docker container in the last step, you should be able to access the local OPA</p>"},{"location":"core/getting_started/running/#specifying-configuration","title":"Specifying configuration","text":"<p>Configuration can be specified with each required item being spoecified in a credential file located in the home directory, a command-line argument, an enviornment variable, or in a json configuration file.</p>"},{"location":"core/getting_started/running/#configration-file","title":"Configration File","text":"<p>You can specify most or all of the arguments as a json dictionary stored in <code>~/.opsbox.json</code>, similar to the AWS main.</p>"},{"location":"core/getting_started/running/#custom-configuration-file-path","title":"Custom Configuration File Path","text":"<p>To use a configuration file in another part, simply use the <code>--config &lt;filepath&gt;</code> argument.</p>"},{"location":"core/getting_started/running/#command-line-arguments","title":"Command-line Arguments","text":"<p>You can specify all the arguments as double-dashed arguments after the <code>--modules</code> argument.</p>"},{"location":"core/getting_started/running/#resolution-order","title":"Resolution order","text":"<p>Configuration will be looked for based on what modules are specified. Each argument will be resolved in the following order:</p> <ol> <li>If <code>--config</code> is specified, look in that file first.</li> <li>Then, if it is in the home configuration file, load that.</li> <li>Then, if it is in the command line arguments, load that.</li> <li>Finally, if it is nowhere else, enviroment variables are used.</li> </ol>"},{"location":"core/plugins/available_plugins/","title":"Plugin Documentation","text":"<p>This document provides an overview of the various plugins implemented for gathering and processing data, interacting with external services, and outputting results. The plugins are categorized into provider plugins for data gathering, assistant plugins for interacting with external services, and output plugins for processing and displaying results.</p>"},{"location":"core/plugins/available_plugins/#table-of-contents","title":"Table of Contents","text":""},{"location":"core/plugins/available_plugins/#provider-plugins","title":"Provider Plugins","text":"<ul> <li>EC2Provider</li> <li>ELBProvider</li> <li>RDSProvider</li> <li>S3Provider</li> <li>IAMProvider</li> <li>Route53Provider</li> <li>CloudWatchProvider</li> </ul>"},{"location":"core/plugins/available_plugins/#assistant-plugins","title":"Assistant Plugins","text":"<ul> <li>Cost Savings</li> <li>Lower Cost</li> </ul>"},{"location":"core/plugins/available_plugins/#output-plugins","title":"Output Plugins","text":"<ul> <li>JiraOutput</li> <li>EmailOutput</li> <li>SlackOutput</li> <li>CLIOutput</li> <li>TextFileOutput</li> <li>GithubOutput</li> <li>AzureOutput</li> <li>PagerDutyOutput</li> <li>JSONOutput</li> </ul>"},{"location":"core/plugins/available_plugins/#rego-plugins","title":"Rego Plugins","text":"<ul> <li>Rego Checks</li> </ul>"},{"location":"core/plugins/available_plugins/#ec2provider","title":"EC2Provider","text":"<p>To install with pip, run <code>pip install opsbox-ec2-provider</code>. To install with UV, run <code>uv add opsbox-ec2-provider</code></p>"},{"location":"core/plugins/available_plugins/#overview","title":"Overview","text":"<p>The EC2Provider plugin collects detailed information about AWS EC2 instances, including their associated volumes and Elastic IP addresses, to facilitate monitoring and management.</p>"},{"location":"core/plugins/available_plugins/#required-fields","title":"Required Fields","text":"<pre><code>    aws_access_key_id: Annotated[str, Field(..., description=\"AWS access key ID\", required=True)]\n    aws_secret_access_key: Annotated[str, Field(..., description=\"AWS secret access key\", required=True)]\n    aws_region: Annotated[str |  None, Field(description=\"AWS region\", required=False,default=None)]\n    volume_tags: Annotated[\n        str | None, Field(description=\"Key-value tag pairs for volumes\", required=False, default=None)\n    ]\n    instance_tags: Annotated[\n        str | None, Field(description=\"Key-value tag pairs for instances\", required=False, default=None)\n    ]\n    eip_tags: Annotated[\n        str | None, Field(description=\"Key-value tag pairs for Elastic IPs\", required=False, default=None)\n    ]\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks","title":"Related Checks","text":"<ul> <li>IdleInstances</li> <li>StrayEbs</li> </ul>"},{"location":"core/plugins/available_plugins/#elbprovider","title":"ELBProvider","text":"<p>To install with pip, run <code>pip install opsbox-elb-provider</code>. To install with UV, run <code>uv add opsbox-elb-provider</code></p>"},{"location":"core/plugins/available_plugins/#overview_1","title":"Overview","text":"<p>The ELBProvider plugin gathers comprehensive data about AWS Elastic Load Balancers, including Classic, Application, and Network Load Balancers, to optimize performance and identify potential issues.</p>"},{"location":"core/plugins/available_plugins/#required-fields_1","title":"Required Fields","text":"<pre><code>    aws_access_key_id: Annotated[str,Field(..., description=\"AWS access key ID\", required=True)]\n    aws_secret_access_key: Annotated[str,Field(..., description=\"AWS secret access key\", required=True)]\n    aws_region: Annotated[\n        str | None, Field(description=\"AWS-Region\", required=False, default=None)\n    ]\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks_1","title":"Related Checks","text":"<ul> <li>HighErrorRate</li> <li>InactiveLoadBalancers</li> <li>LowRequestCount</li> </ul>"},{"location":"core/plugins/available_plugins/#rdsprovider","title":"RDSProvider","text":"<p>To install with pip, run <code>pip install opsbox-rds-provider</code>. To install with UV, run <code>uv add opsbox-rds-provider</code></p>"},{"location":"core/plugins/available_plugins/#overview_2","title":"Overview","text":"<p>The RDSProvider plugin collects information about AWS RDS instances to help manage and optimize database performance and cost.</p>"},{"location":"core/plugins/available_plugins/#required-fields_2","title":"Required Fields","text":"<pre><code>    aws_access_key_id: Annotated[str,Field(..., description=\"AWS access key ID\", required=True)]\n    aws_secret_access_key: Annotated[str,Field(..., description=\"AWS secret access key\", required=True)]\n    aws_region: Annotated[\n        str | None, Field(description=\"AWS-Region\", required=False, default=None)\n    ]\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks_2","title":"Related Checks","text":"<ul> <li>EmptyStorage</li> <li>RDSIdle</li> <li>ScalingDown</li> </ul>"},{"location":"core/plugins/available_plugins/#s3provider","title":"S3Provider","text":"<p>To install with pip, run <code>pip install opsbox-s3-provider</code>. To install with UV, run <code>uv add opsbox-s3-provider</code></p>"},{"location":"core/plugins/available_plugins/#overview_3","title":"Overview","text":"<p>The S3Provider plugin gathers data related to AWS S3, including information about buckets, objects, and storage classes, to assist in storage management and cost optimization.</p>"},{"location":"core/plugins/available_plugins/#required-fields_3","title":"Required Fields","text":"<pre><code>    aws_access_key_id: Annotated[str,Field(..., description=\"AWS access key ID\", required=True)]\n    aws_secret_access_key: Annotated[str,Field(..., description=\"AWS secret access key\", required=True)]\n    aws_region: Annotated[\n        str | None, Field(description=\"AWS-Region\", required=False, default=None)\n    ]\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks_3","title":"Related Checks","text":"<ul> <li>ObjectLastModified</li> <li>StorageClassUsage</li> <li>UnusedBuckets</li> </ul>"},{"location":"core/plugins/available_plugins/#iamprovider","title":"IAMProvider","text":"<p>To install with pip, run <code>pip install opsbox-iam-provider</code>. To install with UV, run <code>uv add opsbox-iam-provider</code></p>"},{"location":"core/plugins/available_plugins/#overview_4","title":"Overview","text":"<p>The IAMProvider plugin collects data related to AWS IAM, including information about users, groups, and roles, to help manage access and permissions effectively.</p>"},{"location":"core/plugins/available_plugins/#required-fields_4","title":"Required Fields","text":"<pre><code>   aws_access_key_id: Annotated[str | None, Field(description=\"AWS access key ID\", required=False,default=None)]\n    aws_secret_access_key: Annotated[str | None, Field(description=\"AWS secret access key\", required=False,default=None)]\n    aws_region: Annotated[str | None, Field(description=\"AWS region\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks_4","title":"Related Checks","text":"<ul> <li>Console_Acess</li> <li>mfa_enabled</li> <li>overdue_api_keys</li> <li>usued_policy</li> </ul>"},{"location":"core/plugins/available_plugins/#route53provider","title":"Route53Provider","text":"<p>To install with pip, run <code>pip install opsbox-r53-provider</code>. To install with UV, run <code>uv add opsbox-r53-provider</code></p>"},{"location":"core/plugins/available_plugins/#overview_5","title":"Overview","text":"<p>The Route53Provider plugin collects data related to AWS Route53, including information about hosted zones, records, and health checks, to help manage DNS and routing effectively.</p>"},{"location":"core/plugins/available_plugins/#required-fields_5","title":"Required Fields","text":"<pre><code>    aws_access_key_id: Annotated[str, Field(..., description=\"AWS access key ID\", required=True)]\n    aws_secret_access_key: Annotated[str, Field(..., description=\"AWS secret access key\", required=True)]\n    aws_region: Annotated[str | None, Field(description=\"AWS region\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks_5","title":"Related Checks","text":"<ul> <li>empty_zones</li> </ul>"},{"location":"core/plugins/available_plugins/#cloudwatchprovider","title":"CloudWatchProvider","text":""},{"location":"core/plugins/available_plugins/#overview_6","title":"Overview","text":"<p>The CloudWatchProvider plugin collects data related to AWS CloudWatch, including metrics and alarms, to help monitor and manage AWS resources effectively.</p>"},{"location":"core/plugins/available_plugins/#required-fields_6","title":"Required Fields","text":"<pre><code>   aws_access_key_id: str = Field(..., description=\"AWS access key ID\")\n    aws_secret_access_key: str = Field(..., description=\"AWS secret access key\")\n    aws_region: str = Field(..., description=\"AWS region\")\n</code></pre>"},{"location":"core/plugins/available_plugins/#related-checks_6","title":"Related Checks","text":"<ul> <li>cw_insights</li> </ul>"},{"location":"core/plugins/available_plugins/#cost-savings","title":"Cost Savings","text":"<p>To install with pip, run <code>pip install opsbox-cost-savings-assistant</code>. To install with UV, run <code>uv add opsbox-cost-savings-assistant</code></p>"},{"location":"core/plugins/available_plugins/#overview_7","title":"Overview","text":"<p>The Cost Savings plugin leverages large language models (LLMs) to generate recommendations for reducing cloud infrastructure costs based on the latest pipeline analysis.</p> <p>Module: <code>cost_savings</code></p>"},{"location":"core/plugins/available_plugins/#used-fields","title":"Used Fields","text":"<pre><code>    arrigator: bool = Field(..., description=\"Whether to aggregate the data and generate one response.\")\n    discard_prior: bool = Field(\n        False, description=\"Whether to discard the data before and leave only cost saving data.\"\n    )\n</code></pre> <p>A Claude key or OpenAI key is required for generating content:</p> <pre><code>claude_key: Annotated[str | None, Field(description=\"The Claude API key used for generating email content.\", required=False, default=None)]\noai_key: Annotated[str | None, Field(description=\"The OpenAI API key used for generating email content.\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#lower-cost","title":"Lower Cost","text":""},{"location":"core/plugins/available_plugins/#overview_8","title":"Overview","text":"<p>A plugin to generate recommendations for lowering costs on AWS EC2 instances.</p> <p>Module: <code>lower_cost</code></p>"},{"location":"core/plugins/available_plugins/#used-fields_1","title":"Used Fields","text":"<pre><code>    aws_access_key_id: str = Field(..., description=\"AWS access key ID\")\n    aws_secret_access_key: str = Field(..., description=\"AWS secret access key\")\n    aws_region: str = Field(..., description=\"AWS region\")\n</code></pre>"},{"location":"core/plugins/available_plugins/#jiraoutput","title":"JiraOutput","text":"<p>To install with pip, run <code>pip install opsbox-jira-output</code>. To install with UV, run <code>uv add opsbox-jira-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_9","title":"Overview","text":"<p>The JiraOutput plugin creates and manages Jira issues based on check results, enabling effective tracking and resolution of identified problems.</p> <p>Module: <code>jira_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_7","title":"Required Fields","text":"<pre><code>jira_url: Annotated[str, Field(description=\"The URL of the Jira instance for issue creation.\", required=True)]\njira_email: Annotated[str, Field(description=\"The email address used for authenticating to Jira.\", required=True)]\njira_api_token: Annotated[str, Field(description=\"The API token used for authenticating to Jira.\", required=True)]\njira_project_key: Annotated[str, Field(description=\"The key of the Jira project where issues will be created.\", required=True)]\n</code></pre> <p>Currently, only OpenAI is supported for Jira:</p> <pre><code>oai_key: Annotated[str, Field(description=\"The OpenAI API key used to assist with issue creation.\", required=True)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#emailoutput","title":"EmailOutput","text":"<p>To install with pip, run <code>pip install opsbox-email-output</code>. To install with UV, run <code>uv add opsbox-email-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_10","title":"Overview","text":"<p>The EmailOutput plugin sends out email notifications based on check results, ensuring that relevant stakeholders are informed in a timely manner.</p> <p>Module: <code>email_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_8","title":"Required Fields","text":"<pre><code>smtp_username: Annotated[str, Field(description=\"The username for SMTP server authentication.\", required=True)]\nsmtp_password: Annotated[str, Field(description=\"The password for SMTP server authentication.\", required=True)]\nsmtp_server: Annotated[str, Field(description=\"The SMTP server used for sending emails.\", required=True)]\nsmtp_port: Annotated[str, Field(description=\"The port used for connecting to the SMTP server.\", required=True)]\nreceiver_email_list: Annotated[str, Field(description=\"A comma-separated list of recipient email addresses.\", required=True)]\n</code></pre> <p>A Claude key or OpenAI key is required for generating content:</p> <pre><code>claude_key: Annotated[str | None, Field(description=\"The Claude API key used for generating email content.\", required=False, default=None)]\noai_key: Annotated[str | None, Field(description=\"The OpenAI API key used for generating email content.\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#slackoutput","title":"SlackOutput","text":"<p>To install with pip, run <code>pip install opsbox-slack-output</code>. To install with UV, run <code>uv add opsbox-slack-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_11","title":"Overview","text":"<p>The SlackOutput plugin sends messages to specified Slack channels based on pipeline outputs, providing real-time alerts to relevant teams.</p> <p>Module: <code>slack_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_9","title":"Required Fields","text":"<pre><code>slack_token: Annotated[str, Field(description=\"The Slack token used for authentication.\", required=True)]\nslack_channel: Annotated[str, Field(description=\"The Slack channel where the message will be posted.\", required=True)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#clioutput","title":"CLIOutput","text":"<p>To install with pip, run <code>pip install opsbox-cli-output</code>. To install with UV, run <code>uv add opsbox-cli-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_12","title":"Overview","text":"<p>The CLIOutput plugin displays results directly in the command line interface, providing quick and accessible feedback.</p> <p>Module: <code>cli_out</code></p>"},{"location":"core/plugins/available_plugins/#textfileoutput","title":"TextFileOutput","text":"<p>To install with pip, run <code>pip install opsbox-text-file-output</code>. To install with UV, run <code>uv add opsbox-text-file-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_13","title":"Overview","text":"<p>The TextFileOutput plugin writes output results to a text file for record-keeping and further analysis.</p> <p>Module: <code>text_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_10","title":"Required Fields","text":"<pre><code>output_folder: Annotated[str | None, Field(description=\"The folder to output the results to.\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#githuboutput","title":"GithubOutput","text":"<p>To install with pip, run <code>pip install opsbox-github-output</code>. To install with UV, run <code>uv add opsbox-github-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_14","title":"Overview","text":"<p>The GithubOutput plugin creates GitHub issues based on pipeline outputs, helping track and manage tasks or problems identified during analysis.</p> <p>Module: <code>github_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_11","title":"Required Fields","text":"<pre><code>github_token: Annotated[str, Field(description=\"The token for authenticating the GitHub user.\", required=True)]\nrepo_owner: Annotated[str, Field(description=\"The owner of the repository where the issue will be created.\", required=True)]\nrepo_name: Annotated[str, Field(description=\"The name of the repository where the issue will be created.\", required=True)]\nlabels: Annotated[str | None, Field(description=\"Labels to apply to the created issue.\", required=False, default=None)]\ncreate_description: Annotated[bool, Field(description=\"Indicates whether to create a detailed description instead of an issue.\", required=False, default=False)]\n</code></pre> <p>A Claude key or Open AI Keys are required if you have create_description set to true</p> <pre><code>claude_key: Annotated[str | None,Field(description=\"The Claude API key to use.\", required=False, default=None)]\n</code></pre> <pre><code>oai_key: Annotated[str | None, Field(description=\"The OpenAI API key to use.\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#azureoutput","title":"AzureOutput","text":"<p>To install with pip, run <code>pip install opsbox-azure-output</code>. To install with UV, run <code>uv add opsbox-azure-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_15","title":"Overview","text":"<p>The AzureOutput plugin creates and manages Azure DevOps work items based on pipeline outputs, facilitating effective issue tracking and resolution.</p> <p>Module: <code>azure_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_12","title":"Required Fields","text":"<pre><code>azure_devops_token: Annotated[str, Field(description=\"The personal access token for authenticating with Azure DevOps.\", required=True)]\nazure_devops_organization: Annotated[str, Field(description=\"The name of the Azure DevOps organization.\", required=True)]\nazure_devops_project: Annotated[str, Field(description=\"The name of the Azure DevOps project.\", required=True)]\nazure_devops_username: Annotated[str, Field(description=\"The username used for authenticating with Azure DevOps.\", required=True)]\nazure_devops_priority: Annotated[int, Field(description=\"The priority level for the work item.\", required=False, default=4)]\ntags: Annotated[str | None, Field(description=\"Tags to apply to the work item.\", required=False, default=None)]\ncreate_description: Annotated[bool, Field(description=\"Indicates whether to create a detailed description instead of an issue.\", required=False, default=False)]\n</code></pre> <p>A Claude key or Open AI Keys are required if you have create_description set to true</p> <pre><code>    claude_key: Annotated[str | None,Field(description=\"The Claude API key to use.\", required=False, default=None)]\n</code></pre> <pre><code>    oai_key: Annotated[str | None, Field(description=\"The OpenAI API key to use.\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#pagerdutyoutput","title":"PagerDutyOutput","text":"<p>To install with pip, run <code>pip install opsbox-pagerduty-output</code>. To install with UV, run <code>uv add opsbox-pagerduty-output</code></p>"},{"location":"core/plugins/available_plugins/#overview_16","title":"Overview","text":"<p>The PagerDutyOutput plugin sends alerts to PagerDuty based on pipeline outputs, ensuring prompt incident response and management.</p> <p>Module: <code>pagerduty_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_13","title":"Required Fields","text":"<pre><code>    routing_key: Annotated[str, Field(description=\"The routing_key to use.\", required=True)]\n    create_description: Annotated[bool,\n    Field(description=\"Whether to create a description instead of an issue.\", required=False, default=False)]\n</code></pre> <p>A Claude key or Open AI Keys are required if you have create_description set to true</p> <pre><code>    claude_key: Annotated[str | None,Field(description=\"The Claude API key to use.\", required=False, default=None)]\n</code></pre> <pre><code>    oai_key: Annotated[str | None, Field(description=\"The OpenAI API key to use.\", required=False, default=None)]\n</code></pre>"},{"location":"core/plugins/available_plugins/#jsonoutput","title":"JSONOutput","text":""},{"location":"core/plugins/available_plugins/#overview_17","title":"Overview","text":"<p>The JSONOutput plugin writes output results to a JSON file for further processing and analysis.</p> <p>Module: <code>json_out</code></p>"},{"location":"core/plugins/available_plugins/#required-fields_14","title":"Required Fields","text":"<pre><code>          output_folder: Annotated[ str | None, Field(default=\"./findings/\", description=\"The folder to output the results to.\", required=False) ]\n</code></pre>"},{"location":"core/plugins/available_plugins/#checks","title":"Checks","text":"<p>To install checks for the services you want, simply run <code>pip install opsbox-&lt;service_name&gt;-checks</code> if using pip and <code>uv add opsbox-&lt;service_name&gt;-checks</code> if using uv.</p> <p>Available services include <code>s3</code>, <code>rds</code>, <code>elb</code>, route53 (accessed by using <code>r53</code>), <code>ec2</code>, and <code>aws-iam</code>.</p>"},{"location":"core/plugins/available_plugins/#idle_instances","title":"idle_instances","text":""},{"location":"core/plugins/available_plugins/#overview_18","title":"Overview","text":"<p>Checks for EC2 instances that are idle, determined by low CPU utilization.</p>"},{"location":"core/plugins/available_plugins/#details","title":"Details","text":"<ul> <li>Module: <code>idle_instances</code></li> <li>Rego File: <code>idle_instances.rego</code></li> <li>Gather From: <code>EC2</code></li> </ul>"},{"location":"core/plugins/available_plugins/#stray_ebs","title":"stray_ebs","text":""},{"location":"core/plugins/available_plugins/#overview_19","title":"Overview","text":"<p>Identifies EBS volumes that are not in use.</p>"},{"location":"core/plugins/available_plugins/#details_1","title":"Details","text":"<ul> <li>Module: <code>stray_ebs</code></li> <li>Rego File: <code>stray_ebs.rego</code></li> <li>Gather From: <code>EC2</code></li> </ul>"},{"location":"core/plugins/available_plugins/#high_error_rate","title":"high_error_rate","text":""},{"location":"core/plugins/available_plugins/#overview_20","title":"Overview","text":"<p>Checks for ELBs with high error rates.</p>"},{"location":"core/plugins/available_plugins/#details_2","title":"Details","text":"<ul> <li>Module: <code>high_error_rate</code></li> <li>Rego File: <code>high_error_rate.rego</code></li> <li>Gather From: <code>ELB</code></li> </ul>"},{"location":"core/plugins/available_plugins/#inactive_load_balancers","title":"inactive_load_balancers","text":""},{"location":"core/plugins/available_plugins/#overview_21","title":"Overview","text":"<p>Identifies underutilized ELBs based on request counts.</p>"},{"location":"core/plugins/available_plugins/#details_3","title":"Details","text":"<ul> <li>Module: <code>inactive_load_balancers</code></li> <li>Rego File: <code>inactive_load_balancers.rego</code></li> <li>Gather From: <code>ELB</code></li> </ul>"},{"location":"core/plugins/available_plugins/#no_healthy_targets","title":"no_healthy_targets","text":""},{"location":"core/plugins/available_plugins/#overview_22","title":"Overview","text":"<p>Identifies ELBs with no healthy targets.</p>"},{"location":"core/plugins/available_plugins/#details_4","title":"Details","text":"<ul> <li>Module: <code>no_healthy_targets</code></li> <li>Rego File: <code>no_healthy_targets.rego</code></li> <li>Gather From: <code>ELB</code></li> </ul>"},{"location":"core/plugins/available_plugins/#low_request_count","title":"low_request_count","text":""},{"location":"core/plugins/available_plugins/#overview_23","title":"Overview","text":"<p>Identifies ELBs with low request counts.</p>"},{"location":"core/plugins/available_plugins/#details_5","title":"Details","text":"<ul> <li>Module: <code>low_request_count</code></li> <li>Rego File: <code>low_request_count.rego</code></li> <li>Gather From: <code>ELB</code></li> </ul>"},{"location":"core/plugins/available_plugins/#empty_storage","title":"empty_storage","text":""},{"location":"core/plugins/available_plugins/#overview_24","title":"Overview","text":"<p>Checks for RDS instances with low storage utilization.</p>"},{"location":"core/plugins/available_plugins/#details_6","title":"Details","text":"<ul> <li>Module: <code>empty_storage</code></li> <li>Rego File: <code>empty_storage.rego</code></li> <li>Gather From: <code>RDS</code></li> </ul>"},{"location":"core/plugins/available_plugins/#rds_idle","title":"rds_idle","text":""},{"location":"core/plugins/available_plugins/#overview_25","title":"Overview","text":"<p>Identifies underutilized RDS instances with low CPU utilization and connections.</p>"},{"location":"core/plugins/available_plugins/#details_7","title":"Details","text":"<ul> <li>Module: <code>rds_idle</code></li> <li>Rego File: <code>rds_idle.rego</code></li> <li>Gather From: <code>RDS</code></li> </ul>"},{"location":"core/plugins/available_plugins/#overview_26","title":"Overview","text":"<p>Provides recommendations for scaling down RDS instances based on low CPU utilization.</p>"},{"location":"core/plugins/available_plugins/#details_8","title":"Details","text":"<ul> <li>Module: <code>scaling_down</code></li> <li>Rego File: <code>scaling_down.rego</code></li> <li>Gather From: <code>RDS</code></li> </ul>"},{"location":"core/plugins/available_plugins/#object_last_modified","title":"object_last_modified","text":""},{"location":"core/plugins/available_plugins/#overview_27","title":"Overview","text":"<p>Identifies inactive S3 objects that haven't been modified in over 90 days.</p>"},{"location":"core/plugins/available_plugins/#details_9","title":"Details","text":"<ul> <li>Module: <code>object_last_modified</code></li> <li>Rego File: <code>object_last_modified.rego</code></li> <li>Gather From: <code>S3</code></li> </ul>"},{"location":"core/plugins/available_plugins/#storage_class_usage","title":"storage_class_usage","text":""},{"location":"core/plugins/available_plugins/#overview_28","title":"Overview","text":"<p>Checks the usage of different storage classes in S3 buckets.</p>"},{"location":"core/plugins/available_plugins/#details_10","title":"Details","text":"<ul> <li>Module: <code>storage_class_usage</code></li> <li>Rego File: <code>storage_class_usage.rego</code></li> <li>Gather From: <code>S3</code></li> </ul>"},{"location":"core/plugins/available_plugins/#unused_buckets","title":"unused_buckets","text":""},{"location":"core/plugins/available_plugins/#overview_29","title":"Overview","text":"<p>Identifies unused S3 buckets based on their last modified time.</p>"},{"location":"core/plugins/available_plugins/#details_11","title":"Details","text":"<ul> <li>Module: <code>unused_buckets</code></li> <li>Rego File: <code>unused_buckets.rego</code></li> <li>Gather From: <code>S3</code></li> </ul>"},{"location":"core/plugins/available_plugins/#console_access","title":"console_access","text":""},{"location":"core/plugins/available_plugins/#overview_30","title":"Overview","text":"<p>Identifies users with console access.</p>"},{"location":"core/plugins/available_plugins/#details_12","title":"Details","text":"<ul> <li>Module: <code>console_access</code></li> <li>Rego File: <code>console_access.rego</code></li> <li>Gather From: <code>IAM</code></li> </ul>"},{"location":"core/plugins/available_plugins/#mfa_enabled","title":"mfa_enabled","text":""},{"location":"core/plugins/available_plugins/#overview_31","title":"Overview","text":"<p>Identifies users with MFA disabled.</p>"},{"location":"core/plugins/available_plugins/#details_13","title":"Details","text":"<ul> <li>Module: <code>mfa_enabled</code></li> <li>Rego File: <code>mfa_enabled.rego</code></li> <li>Gather From: <code>IAM</code></li> </ul>"},{"location":"core/plugins/available_plugins/#overdue_api_keys","title":"overdue_api_keys","text":""},{"location":"core/plugins/available_plugins/#overview_32","title":"Overview","text":"<p>Identifies API keys that are overdue for rotation.</p>"},{"location":"core/plugins/available_plugins/#details_14","title":"Details","text":"<ul> <li>Module: <code>overdue_api_keys</code></li> <li>Rego File: <code>overdue_api_keys.rego</code></li> <li>Gather From: <code>IAM</code></li> </ul>"},{"location":"core/plugins/available_plugins/#unused_policy","title":"unused_policy","text":""},{"location":"core/plugins/available_plugins/#overview_33","title":"Overview","text":"<p>Identifies unused policies in IAM.</p>"},{"location":"core/plugins/available_plugins/#details_15","title":"Details","text":"<ul> <li>Module: <code>unused_policy</code></li> <li>Rego File: <code>unused_policy.rego</code></li> <li>Gather From: <code>IAM</code></li> </ul>"},{"location":"core/plugins/available_plugins/#empty_zones","title":"empty_zones","text":""},{"location":"core/plugins/available_plugins/#overview_34","title":"Overview","text":"<p>Identifies empty hosted zones in Route53.</p>"},{"location":"core/plugins/available_plugins/#details_16","title":"Details","text":"<ul> <li>Module: <code>empty_zones</code></li> <li>Rego File: <code>empty_zones.rego</code></li> <li>Gather From: <code>Route53</code></li> </ul>"},{"location":"core/plugins/available_plugins/#cw_insights","title":"cw_insights","text":""},{"location":"core/plugins/available_plugins/#overview_35","title":"Overview","text":"<p>provideds Cloudwatch metrics from boto3.</p>"},{"location":"core/plugins/available_plugins/#details_17","title":"Details","text":"<ul> <li>Module: <code>cw_insights</code></li> <li>Rego File: <code>cw_insights.rego</code></li> <li>Gather From: <code>CloudWatch</code></li> </ul>"},{"location":"core/plugins/development_basics/","title":"Building Plugins for Opsbox","text":"<p>Creating plugins for Opsbox is a straightforward process with a few key steps. Let's walk through them!</p>"},{"location":"core/plugins/development_basics/#tip","title":"Tip","text":"<p>Opsbox uses the Pluggy library for plugin management, loading, and validation. If you're familiar with Pluggy, this workflow will feel familiar.</p>"},{"location":"core/plugins/development_basics/#steps-to-build-plugins","title":"Steps to Build Plugins","text":"<ol> <li>Specify your hookimpl</li> <li>Define configurations (optional)</li> <li>Define activation (optional)</li> <li>Add plugin toml file</li> <li>Use results model</li> <li>Package it up (optional)</li> <li>Add more!</li> </ol>"},{"location":"core/plugins/development_basics/#specify-your-hookimpl","title":"Specify Your Hookimpl","text":"<p>Pluggy operates using a system of hook specifications (\"hookspecs\"), which define methods to be implemented. To create a plugin, you implement methods from these hookspecs and designate these methods as hook implementations.</p> <p>To specify a hook implementation, import <code>HookimplMarker</code> from Pluggy and set the project to <code>\"opsbox\"</code>:</p> <pre><code>from pluggy import HookimplMarker\n\n# Define a hookimpl (implementation of the contract)\nhookimpl = HookimplMarker(\"opsbox\")\n</code></pre>"},{"location":"core/plugins/development_basics/#implement-basespec","title":"Implement Basespec","text":"<p>Opsbox plugins can optionally: - Specify configuration through a Pydantic model. - Specify delayed activation that executes after setting plugin data.</p> <p>All hook implementations should be collected from a single class, meaning all hook implementations should be within the same class.</p>"},{"location":"core/plugins/development_basics/#example-implementation","title":"Example Implementation","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pluggy import HookimplMarker\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass CostAssistant:\n\n    @hookimpl\n    def grab_config(self) -&gt; type[BaseModel]:\n        \"\"\"Return the plugin's configuration Pydantic model.\"\"\"\n        class OAICostConfig(BaseModel):\n            oai_assistant_id: str = Field(..., description=\"The ID of the OpenAI assistant\")\n            oai_vector_store_id: str = Field(..., description=\"The ID of the OpenAI vector store\")\n            oai_key: str = Field(..., description=\"The OpenAI API key\")\n        return OAICostConfig\n\n    @hookimpl\n    def set_data(self, model: BaseModel) -&gt; None:\n        \"\"\"Set the plugin's data.\"\"\"\n        self.config = model\n\n    @hookimpl\n    def activate(self) -&gt; None:\n        \"\"\"Activate the plugin by initializing the OpenAI client.\"\"\"\n        self.client = OpenAI(api_key=self.config.oai_key)\n</code></pre>"},{"location":"core/plugins/development_basics/#define-configuration-optional","title":"Define Configuration (Optional)","text":"<p>To define the expected configuration for your plugin, implement the <code>grab_config</code> and <code>set_data</code> methods. These methods should return a Pydantic model with necessary attributes and set class data, respectively. The model attributes for will be checked for upon startup in the applications configuration parameters.</p>"},{"location":"core/plugins/development_basics/#example-configuration","title":"Example Configuration","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pluggy import HookimplMarker\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass CostAssistant:\n\n    @hookimpl\n    def grab_config(self) -&gt; type[BaseModel]:\n        \"\"\"Return the plugin's configuration Pydantic model.\"\"\"\n        class OAICostConfig(BaseModel):\n            oai_assistant_id: str = Field(..., description=\"The ID of the OpenAI assistant\")\n            oai_vector_store_id: str = Field(..., description=\"The ID of the OpenAI vector store\")\n            oai_key: str = Field(..., description=\"The OpenAI API key\")\n        return OAICostConfig\n\n    @hookimpl\n    def set_data(self, model: BaseModel) -&gt; None:\n        \"\"\"Set the plugin's data.\"\"\"\n        self.config = model\n</code></pre>"},{"location":"core/plugins/development_basics/#define-activation-optional","title":"Define Activation (Optional)","text":"<p>Sometimes, you need to initialize data before processing but after setting the class' data. Use an <code>activate</code> function to achieve this.</p>"},{"location":"core/plugins/development_basics/#example-activation","title":"Example Activation","text":"<pre><code>from openai import OpenAI\nfrom pydantic import BaseModel, Field\nfrom pluggy import HookimplMarker\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass CostAssistant:\n\n    @hookimpl\n    def grab_config(self) -&gt; type[BaseModel]:\n        \"\"\"Return the plugin's configuration Pydantic model.\"\"\"\n        class OAICostConfig(BaseModel):\n            oai_assistant_id: str = Field(..., description=\"The ID of the OpenAI assistant\")\n            oai_vector_store_id: str = Field(..., description=\"The ID of the OpenAI vector store\")\n            oai_key: str = Field(..., description=\"The OpenAI API key\")\n        return OAICostConfig\n\n    @hookimpl\n    def set_data(self, model: BaseModel) -&gt; None:\n        \"\"\"Set the plugin's data.\"\"\"\n        self.config = model\n\n    @hookimpl\n    def activate(self) -&gt; None:\n        \"\"\"Activate the plugin by initializing the OpenAI client.\"\"\"\n        self.client = OpenAI(api_key=self.config.oai_key)\n</code></pre>"},{"location":"core/plugins/development_basics/#define-plugin-info-toml-file","title":"Define plugin info toml file","text":"<p>Each plugin should include a TOML file with essential information. The TOML file should be in the following format:</p> <pre><code>[info]\nname = \"Plugin Name\"\nmodule = \"plugin_module\"\nclass_name = \"PluginClassInModule\"\ntype = \"assistant\"\nuses = [\"general\"]\n</code></pre> <p>Where: - <code>name</code> is what you'll refer to the plugin as (please no spaces!) - <code>module</code> is the name of your python module (normally found from your .py file) - <code>class_name</code> is the class in the module that corresponds to your plugin. - <code>type</code> is the type of the plugin. This allows us to dispatch plugins to the right handler. - <code>uses</code> is a list of used plugins, handlers, etc. <p>For Rego checks, include additional information:</p> <pre><code>...\n\nuses = [\"provider_name\", \"rego\"]\n[rego]\nrego_file = \"path/to/regofile.rego\"\ndescription = \"Description of policy results\"\n</code></pre> <p>(More info can be found in the creating rego plugins document!)</p> <p>It helps to put all your plugin info and modules into a new folder in the plugin directory.</p>"},{"location":"core/plugins/development_basics/#define-other-hookspecs","title":"Define other hookspecs","text":"<p>In order to implement the various types of plugins in Opsbox, you need to implement their respective hooks. </p> <p>All plugins can use hookspecs defined in BaseSpec. These include those that implement basic optional features such as delayed activation and configuration gathering.</p> <p>For the two base handlers, the following hookspecs exist:</p> <p>General Handler - InputSpec, Hooks that implement methods to generate formatted results - ProviderSpec, Hooks that implement methods to gather data that other plugins can rely on - OutputSpec, Hooks that implement methods to output formatted result data - AssistantSpec, Hooks that implement methods to transform formatted data</p> <p>Rego Handler - RegoSpec, Hooks that implement methods to generate formatted results from Rego check outputs.</p> <p>Read the documentation for rego and handler plugins!  They require a bit more than other plugin types.</p> <p>Check out some more of these documents for more info on how to structure various types of plugins.</p>"},{"location":"core/plugins/development_basics/#utilize-the-result-models","title":"Utilize the Result Models","text":"<p>OpsBox uses <code>Result</code> models to represent the outputs of plugins, especially when data needs to be passed between plugins in the pipeline.</p>"},{"location":"core/plugins/development_basics/#understanding-the-result-model","title":"Understanding the Result Model","text":"<p>The <code>Result</code> model is defined as follows:</p> <pre><code>from pydantic import BaseModel\n\nclass Result(BaseModel):\n    \"\"\"A model representing the results of a plugin's processing.\n\n    Attributes:\n        relates_to (str): The entity the result relates to.\n        result_name (str): The name of the result.\n        result_description (str): A description of the result.\n        details (dict | list[dict]): Additional details of the result.\n        formatted (str): A formatted string representation of the result.\n    \"\"\"\n    relates_to: str\n    result_name: str\n    result_description: str\n    details: dict | list[dict]\n    formatted: str\n</code></pre>"},{"location":"core/plugins/development_basics/#how-to-use-the-result-model-in-your-plugin","title":"How to Use the Result Model in Your Plugin","text":"<p>When your plugin processes data and produces output that needs to be passed to subsequent plugins, you should encapsulate that output in a <code>Result</code> object.</p>"},{"location":"core/plugins/development_basics/#example","title":"Example","text":"<p>Suppose you have an input plugin that gathers data and needs to output it for assistant plugins to process.</p> <pre><code>from pydantic import BaseModel\nfrom core.plugins import Result\nfrom pluggy import HookimplMarker\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass ExampleInputPlugin:\n    @hookimpl\n    def process(self, data):\n        # Simulate data gathering\n        gathered_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n\n        # Create a Result object\n        result = Result(\n            relates_to=\"ExampleInputPlugin\",\n            result_name=\"GatheredData\",\n            result_description=\"Data gathered from the example input plugin.\",\n            details=gathered_data,\n            formatted=str(gathered_data)\n        )\n\n        # Return the result in a list\n        return [result]\n</code></pre> <p>In an assistant plugin, you can process the results from previous plugins:</p> <pre><code>from core.plugins import Result\nfrom pluggy import HookimplMarker\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass ExampleAssistantPlugin:\n    @hookimpl\n    def process_input(self, input_results: list[Result]) -&gt; list[Result]:\n        processed_results = []\n        for result in input_results:\n            # Perform some processing on result.details\n            processed_data = {k: v.upper() for k, v in result.details.items()}\n\n            # Create a new Result object\n            new_result = Result(\n                relates_to=result.relates_to,\n                result_name=\"ProcessedData\",\n                result_description=\"Data processed by the assistant plugin.\",\n                details=processed_data,\n                formatted=str(processed_data)\n            )\n            processed_results.append(new_result)\n        return processed_results\n</code></pre> <p>Finally, an output plugin can take the processed results and output them accordingly:</p> <pre><code>from core.plugins import Result\nfrom pluggy import HookimplMarker\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass ExampleOutputPlugin:\n    @hookimpl\n    def process_results(self, results: list[Result]) -&gt; None:\n        for result in results:\n            # Output the formatted result\n            print(f\"Output from {result.relates_to}: {result.formatted}\")\n</code></pre>"},{"location":"core/plugins/development_basics/#packaging-your-plugin-for-distribution","title":"Packaging Your Plugin for Distribution","text":"<p>Opsbox supports loading plugins in the virtual environment without specifying directories.</p> <p>To use this feature, you must package your plugin in a pip-installable distribution with specific entry points.</p> <p>Let's go over each step to produce a pip-installable plugin.</p>"},{"location":"core/plugins/development_basics/#directory-structure","title":"Directory structure","text":"<p>In order to package your plugin, we recommend starting out with a subfolder layout for your module. </p> <p>This might look like this:</p> <p>myproject/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 pyproject.toml \u2514\u2500\u2500 plugin_name/ \u2502       \u251c\u2500\u2500 init.py \u2502       \u251c\u2500\u2500 module1.py |       \u251c\u2500\u2500 manifest.toml \u251c\u2500\u2500 tests/ \u2514\u2500\u2500 docs/</p> <p>This allows us to define setuptools entrypoints and other things.</p>"},{"location":"core/plugins/development_basics/#setup-uv","title":"Setup UV","text":"<p>Make sure to initalize this as a uv project using <code>uv init</code> in the root of your new directory.</p> <p>Add any 3rd party dependencies or packages needed with <code>uv add</code>.</p> <p>If you have multiple plugins in the same repo, it might be worthwhile to investigate uv's workspaces feature.</p>"},{"location":"core/plugins/development_basics/#save-manifest","title":"Save manifest","text":"<p>Follow the prior steps in the tutorial, but save your plugin manifest as manifest.toml and put it in your module's subfolder. This is required to search for the toml file needed.</p>"},{"location":"core/plugins/development_basics/#mess-around-in-pyprojecttoml","title":"Mess around in pyproject.toml","text":"<p>With your plugin created, you now need to define your entrypoints so that opsbox can find the required plugins.</p>"},{"location":"core/plugins/development_basics/#step-1-add-entrypoint","title":"Step 1: Add entrypoint","text":"<p>We need to add a setuptools entrypoint under <code>opsbox.plugins</code> to allow opsbox to see our plugins. </p> <p>Say for example, we have a class <code>TestPlugin</code> defined in <code>module1.py</code> according to the subfolder layout above, and this is the main class of our plugin implementing one of our hooks.</p> <p>We'd want to add the following to our pyproject.toml file</p> <pre><code>[project.entry-points.'opsbox.plugins']\nplugin_name = \"plugin_name.module1:TestPlugin\"\n</code></pre>"},{"location":"core/plugins/development_basics/#step-2-include-metadata","title":"Step 2: Include Metadata","text":"<p>Next step is to include the plugin's manifest so it can be easily found.</p> <p>To do this, add the following to your pyproject file:</p> <pre><code>[tool.setuptools]\ninclude-package-data = true\n\n[tool.setuptools.package-data]\n\"plugin_name\" = [\"manifest.toml\"] # include \"*.rego\" if you are making a rego plugin.\n</code></pre> <p>As long as your manifest is packaged in that subfolder unnder <code>manifest.toml</code>, your plugin should now be buildable.</p>"},{"location":"core/plugins/development_basics/#step-3-building-the-plugin","title":"Step 3: Building the plugin","text":"<p>We will use UV's in-built building tool to build the plugin. </p> <p>Go to the root of the directory and type <code>uv build</code>. If everything goes well, you should be able to find your distribution in the <code>dist/</code> folder in your workspace's root.</p>"},{"location":"core/plugins/development_basics/#best-practices","title":"Best Practices","text":"<ul> <li>Consistency: Ensure that all plugins return their outputs encapsulated in <code>Result</code> objects for consistency across the pipeline.</li> <li>Information Preservation: Include meaningful information in all fields of the <code>Result</code> model to aid in debugging and downstream processing.</li> <li>Avoid Data Loss: When processing results, be careful not to inadvertently discard important information in the <code>details</code> or other fields.</li> </ul>"},{"location":"core/plugins/development_basics/#add-more","title":"Add More!","text":"<p>Feel free to extend your plugins with additional functionality as needed. You can define more methods, utilize other libraries, and customize your plugin to fit your specific requirements.</p>"},{"location":"core/plugins/development_basics/#additional-notes","title":"Additional Notes","text":"<ul> <li>Testing Your Plugin: It's a good idea to write tests for your plugin to ensure it behaves as expected within the OpsBox framework.</li> <li>Documentation: Document your plugin's functionality, configuration options, and any dependencies it may have.</li> <li>Contribution: If you believe your plugin could benefit others, consider contributing it back to the OpsBox community!</li> </ul>"},{"location":"core/plugins/making_checks/","title":"Creating Rego Check Plugins for Opsbox","text":"<p>Rego check plugins are vital for gathering data from a provider plugin, applying a defined policy, and formatting the raw result into a readable format. Let's explore how to create one!</p>"},{"location":"core/plugins/making_checks/#before-you-start","title":"Before You Start","text":"<p>If you haven't read the Plugin Basics and Providers documents, please take a moment to do so. They provide essential information for successfully gathering data, including:</p> <ul> <li>Setting up a proper hookimpl marker to register hook implementations</li> <li>Information on setting up your plugin info document</li> <li>Details on providers to help you get started</li> </ul> <p>While Rego checks don't typically use <code>activate</code> or configuration models, feel free to include them if needed!</p>"},{"location":"core/plugins/making_checks/#requirements","title":"Requirements","text":"<p>Rego check plugins require three things:</p> <ol> <li>A configuration file detailing the location of the Rego file, the provider to gather data from, and the meaning of the check results.</li> <li>A Rego file with a policy that returns meaningful results from the provider data.</li> <li>A Python class with a hook implementation that converts the Rego check results into a human-readable format.</li> </ol>"},{"location":"core/plugins/making_checks/#configuration-file","title":"Configuration File","text":"<p>In addition to the <code>[info]</code> section of your TOML file, you also need to include a <code>[rego]</code> header:</p> <pre><code>[info]\nname = \"Plugin Name\"\nmodule = \"plugin_module\"\nclass_name = \"PluginClassInModule\"\ntype = \"rego\"\nuses = [\"rego\"]\n\n[rego]\nrego_file = \"path/to/regofile.rego\"\ndescription = \"Description of policy results\"\n</code></pre> <ul> <li>type must be <code>\"rego\"</code>.</li> <li> <p>uses list must contain <code>\"rego\"</code>.</p> </li> <li> <p>rego_file points to the rego file.</p> </li> <li>description describes the rego check itself.</li> </ul> <p>These fields tell Opsbox what it needs to know to accurately manage Rego checks.</p>"},{"location":"core/plugins/making_checks/#defining-hook-implementations","title":"Defining Hook Implementations","text":"<p>Rego checks implement the hooks from <code>RegoSpec</code>. The key method to implement is <code>report_findings(self, data: \"Result\") -&gt; \"Result\"</code>. This hook takes in a Result with rego-proccessed details from the rego check speicified and formats it into an LLM-usable text format, returning the result.</p>"},{"location":"core/plugins/making_checks/#what-to-include-in-your-pyproject-file","title":"what to include in your pyproject file","text":"<p>One key thing to note for building installable distributions (see development basics for more!*) is the inclusion of rego files in your metadata.</p> <p>Change the following section in your pyproject.toml file to this to include both your manifest and rego files: <pre><code>[tool.setuptools.package-data]\n\"plugin_name\" = [\"manifest.toml\", \"*.rego\"] # include \"*.rego\" if you are making a rego plugin.\n</code></pre></p>"},{"location":"core/plugins/making_checks/#example-rego-policy","title":"Example Rego Policy","text":"<p>Here\u2019s an example Rego policy for the <code>idle_instances</code> check:</p> <pre><code>package aws.cost.idle_instances\n\ndefault allow = false\n\nallow {\n    instance := input.instances[_]\n    instance.state == \"running\"\n    instance.avg_cpu_utilization &lt; 5  # Threshold for low CPU utilization\n}\n\ndetails := [instance | instance := input.instances[_]; instance.state == \"running\"; instance.avg_cpu_utilization &lt; 5]\n</code></pre> <p>The <code>details</code> dictionary of a rego check can be accessed using the <code>details</code> part of the input Result object.</p>"},{"location":"core/plugins/making_checks/#example-implementation","title":"Example Implementation","text":"<p>Below is an example of the <code>idle_instances</code> plugin:</p> <pre><code>import yaml\nfrom loguru import logger\nfrom core.plugins import Result\n\n\nclass IdleInstances:\n    \"\"\"Plugin for identifying idle EC2 instances.\"\"\"\n\n    def report_findings(self, data: Result) -&gt; Result:\n        \"\"\"Report the findings of the plugin.\n        Attributes:\n            data (CheckResult): The result of the checks.\n        Returns:\n            str: The formatted string containing the findings.\n        \"\"\"\n        findings = data.details\n        instances = []\n        for instance in findings:\n            instance_obj = {\n                instance[\"instance_id\"]: {\n                    \"region\": instance[\"region\"],\n                    \"state\": instance[\"state\"],\n                    \"avg_cpu_utilization\": instance[\"avg_cpu_utilization\"],\n                    \"instance_type\": instance[\"instance_type\"],\n                    \"operating_system\": instance[\"operating_system\"],\n                }\n            }\n            instances.append(instance_obj)\n        try:\n            instance_yaml = yaml.dump(instances, default_flow_style=False)\n        except Exception as e:\n            logger.error(f\"Error formatting instance details: {e}\")\n\n        template = \"\"\"The following EC2 instances are idle, with an average CPU utilization of less than 5%.\nThe data is presented in the following format:\n- instance_id:\n    region: region\n    state: running\n    avg_cpu_utilization:\n\n{instances}\"\"\"\n\n        if instances:\n            return Result(\n                relates_to=\"ec2\",\n                result_name=\"idle_instances\",\n                result_description=\"Idle EC2 Instances\",\n                details=data.details,\n                formatted=template.format(instances=instance_yaml),\n            )\n        else:\n            return Result(\n                relates_to=\"ec2\",\n                result_name=\"idle_instances\",\n                result_description=\"Idle EC2 Instances\",\n                details=data.details,\n                formatted=\"No idle EC2 instances found.\",\n            )\n</code></pre> <p>In this example, <code>report_findings</code> processes the <code>Result</code>, formats it using YAML, and returns a <code>Result</code>.</p> <p>By following these guidelines, you can create effective Rego check plugins for Opsbox, making your cloud infrastructure management more insightful and automated. Happy coding! \ud83d\ude80</p>"},{"location":"core/plugins/making_handlers/","title":"Creating Handlers for OpsBox","text":"<p>Handlers are the orchestrators within the OpsBox Plugin System. They manage and coordinate various types of plugins, ensuring that each plugin operates seamlessly within the defined pipeline. This document will guide you through the process of creating handlers, understanding their types, and integrating them effectively into your OpsBox setup.</p>"},{"location":"core/plugins/making_handlers/#before-you-start","title":"Before You Start","text":"<p>Before you begin creating handlers, it's essential to have a solid understanding of Plugin Basics. Please refer to the Development Basics document, which covers:</p> <ul> <li>Setting up a proper hook implementation marker to register hook implementations</li> <li>Defining expected user configuration values through a Pydantic model</li> <li>Initializing plugin classes through the <code>activate()</code> hook implementation</li> </ul>"},{"location":"core/plugins/making_handlers/#steps-to-create-handlers","title":"Steps to Create Handlers","text":"<ol> <li>Specify Your Hook Implementations</li> <li>Define Handler Configurations (optional)</li> <li>Implement the Handler Class</li> <li>Add Handler TOML File</li> <li>Register and Activate the Handler</li> <li>Integrate the Handler into the Plugin Pipeline</li> <li>Add More!</li> </ol>"},{"location":"core/plugins/making_handlers/#specify-your-hook-implementations","title":"Specify Your Hook Implementations","text":"<p>Handlers in OpsBox utilize hook specifications (\"hookspecs\") to define the contracts they must adhere to. These hookspecs ensure that handlers can manage and process different types of plugins effectively.</p> <p>To specify hook implementations, import <code>HookimplMarker</code> from Pluggy and set the project name to <code>\"opsbox\"</code>:</p> <pre><code>from pluggy import HookimplMarker\n\n# Define a hook implementation marker\nhookimpl = HookimplMarker(\"opsbox\")\n</code></pre>"},{"location":"core/plugins/making_handlers/#define-handler-configurations-optional","title":"Define Handler Configurations (Optional)","text":"<p>While not mandatory, defining configurations for your handler can provide flexibility and control over how it manages different plugin types. Use Pydantic models to define and validate these configurations.</p>"},{"location":"core/plugins/making_handlers/#example-configuration","title":"Example Configuration","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass HandlerConfig(BaseModel):\n    log_level: str = Field(\"INFO\", description=\"Logging level for the handler\")\n    timeout: int = Field(30, description=\"Timeout for plugin processing in seconds\")\n</code></pre>"},{"location":"core/plugins/making_handlers/#implement-the-handler-class","title":"Implement the Handler Class","text":"<p>Create a handler class that implements the required hookspecs. This class will manage specific types of plugins based on your configuration.</p>"},{"location":"core/plugins/making_handlers/#process_plugin-method","title":"<code>process_plugin</code> Method","text":"<p>The process_plugin method is the cornerstone of a handler's functionality within the OpsBox Plugin System. It is responsible for executing a specific plugin based on its type (e.g., input, output, assistant, provider, rego). This method receives three primary parameters:</p> <ul> <li>plugin (PluginInfo): Contains metadata and configuration details about the plugin to be processed.</li> <li>prior_results (list[Result]): A list of results produced by previously executed plugins in the pipeline.</li> <li>registry (Registry): The central registry managing all active plugins and their interactions.</li> </ul> <p>This function describes the flow of the plugin, and executes code according to it's own defined hookspecs on plugin objects that implement them.</p> <p>To do this, we use <code>PluginInfo</code> objects.</p>"},{"location":"core/plugins/making_handlers/#plugininfo-object","title":"<code>PluginInfo</code> Object","text":"<p>The <code>PluginInfo</code> object is a core component of the OpsBox Plugin System, encapsulating all essential metadata and configuration details for each plugin. It serves as a standardized structure that includes attributes such as the plugin's name, module, class name, type (e.g., <code>input</code>, <code>output</code>, <code>assistant</code>), path to its TOML configuration file, and any dependencies it may have (<code>uses</code>). Additionally, it holds references to the instantiated plugin object and its validated configuration data. By utilizing the <code>PluginInfo</code> object, OpsBox ensures consistent management, loading, and execution of plugins within the system.</p> <p>Key Attributes:</p> <ul> <li>name (<code>str</code>): Unique identifier for the plugin.</li> <li>module (<code>str</code>): Python module where the plugin class is defined.</li> <li>class_name (<code>str</code>): Name of the plugin class within the module.</li> <li>type (<code>str</code>): Category of the plugin (e.g., <code>input</code>, <code>output</code>).</li> <li>toml_path (<code>str</code>): File path to the plugin's TOML configuration.</li> <li>plugin_obj (<code>Any | None</code>): Instance of the loaded plugin class.</li> <li>config (<code>BaseModel | None</code>): Validated configuration data for the plugin.</li> <li>uses (<code>list[str]</code>): List of other plugins this plugin depends on.</li> <li>extra (<code>dict[str, Any] | None</code>): Additional metadata or information.</li> </ul> <p>Example Usage:</p> <pre><code>from core.plugins import PluginInfo\n\nplugin_info = PluginInfo(\n    name=\"example_input\",\n    module=\"example_input\",\n    class_name=\"ExampleInputPlugin\",\n    type=\"input\",\n    toml_path=\"path/to/example_input.toml\",\n    uses=[\"provider_plugin\"],\n    extra={\"handler\": {\"handles\"=[\"input\", \"output\", \"assistant\"]}}\n)\n</code></pre> <p>By leveraging the <code>PluginInfo</code> object, developers can easily access and manage plugin-specific information.</p>"},{"location":"core/plugins/making_handlers/#example-general-handler","title":"Example General Handler","text":"<pre><code># general_handler.py\nfrom pluggy import HookimplMarker, PluginManager\nfrom core.plugins import PluginInfo, Result, Registry\nfrom loguru import logger\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass GeneralHandler:\n    \"\"\"General handler for Python plugins.\"\"\"\n\n    @hookimpl\n    def add_hookspecs(self, manager: PluginManager):\n        \"\"\"Add the hookspecs to the manager.\"\"\"\n        from core.base_hooks import AssistantSpec, OutputSpec, ProviderSpec, InputSpec\n        manager.add_hookspecs(AssistantSpec)\n        manager.add_hookspecs(OutputSpec)\n        manager.add_hookspecs(ProviderSpec)\n        manager.add_hookspecs(InputSpec)\n\n    @hookimpl\n    def process_plugin(self, plugin: PluginInfo, prior_results: list[Result], registry: Registry) -&gt; list[Result]:\n        \"\"\"Process the plugin based on its type.\"\"\"\n        logger.debug(f\"GeneralHandler processing plugin {plugin.name}\")\n        if plugin.type == \"input\":\n            # Process input plugin\n            return plugin.plugin_obj.process(prior_results)\n        elif plugin.type == \"output\":\n            # Process output plugin\n            plugin.plugin_obj.process_results(prior_results)\n            return prior_results\n        elif plugin.type == \"assistant\":\n            # Process assistant plugin\n            return plugin.plugin_obj.process_input(prior_results)\n        else:\n            logger.warning(f\"Unknown plugin type: {plugin.type}\")\n            return prior_results\n</code></pre>"},{"location":"core/plugins/making_handlers/#add-handler-toml-file","title":"Add Handler TOML File","text":"<p>Each handler must include a TOML file with essential information. This file informs the OpsBox system about the handler's metadata and the types of plugins it manages.</p>"},{"location":"core/plugins/making_handlers/#example-handler-toml","title":"Example Handler TOML","text":"<pre><code>[info]\nname = \"general\"\nmodule = \"general_handler\"\nclass_name = \"GeneralHandler\"\ntype = \"handler\"\n\n[handler]\nhandles = [\"input\", \"output\", \"assistant\"]\n</code></pre> <p>Explanation:</p> <ul> <li>[info] Section:</li> <li><code>name</code>: Unique name of the handler (<code>\"general\"</code>).</li> <li><code>module</code>: Name of the Python module containing the handler (<code>\"general_handler\"</code>).</li> <li><code>class_name</code>: Name of the handler class (<code>\"GeneralHandler\"</code>).</li> <li> <p><code>type</code>: Must be <code>\"handler\"</code> to designate this plugin as a handler.</p> </li> <li> <p>[handler] Section:</p> </li> <li><code>handles</code>: List of plugin types this handler manages (<code>\"input\"</code>, <code>\"output\"</code>, <code>\"assistant\"</code>).</li> </ul> <p>For specialized handlers like the Rego Handler, the TOML file may include additional sections to handle specific plugin types.</p>"},{"location":"core/plugins/making_handlers/#register-and-activate-the-handler","title":"Register and Activate the Handler","text":"<p>Ensure that your handler is placed in the designated <code>plugin_dir</code> and that the OpsBox <code>Registry</code> is aware of it. The <code>Registry</code> will automatically load and register handlers based on their TOML configurations.</p>"},{"location":"core/plugins/making_handlers/#integrate-the-handler-into-the-plugin-pipeline","title":"Integrate the Handler into the Plugin Pipeline","text":"<p>Once the handler is registered and activated, it will manage the execution of plugins based on their types. Handlers ensure that each plugin is processed correctly within the pipeline.</p>"},{"location":"core/plugins/making_handlers/#example-pipeline-execution","title":"Example Pipeline Execution","text":"<pre><code># Produce the pipeline based on active plugins\npipeline = registry.produce_pipeline()\n\n# Execute the pipeline, managed by the registered handlers\nregistry.process_pipeline(pipeline)\n</code></pre> <p>Output:</p> <pre><code>Activating GeneralHandler with log_level=DEBUG and timeout=60\nActivating ExampleInputPlugin with data source: SampleSource\nProcessing plugin example_input\nProcessing data: [{'key1': 'value1', 'key2': 'value2'}]\n</code></pre>"},{"location":"core/plugins/making_handlers/#add-more","title":"Add More!","text":"<p>Feel free to extend your handlers with additional functionalities as needed. You can define more methods, utilize other libraries, and customize your handler to fit specific requirements.</p>"},{"location":"core/plugins/making_handlers/#faqs","title":"FAQs","text":""},{"location":"core/plugins/making_handlers/#q1-can-a-handler-manage-multiple-plugin-types","title":"Q1: Can a Handler manage multiple Plugin Types?","text":"<p>A1: Yes, a single Handler can manage multiple plugin types. In the handler's TOML configuration file, list all the plugin types it handles under the <code>[handler]</code> section's <code>handles</code> attribute. This allows the Handler to process various plugin types within the same pipeline.</p> <p>Example:</p> <pre><code>[handler]\nhandles = [\"input\", \"output\", \"assistant\", \"transformer\"]\n</code></pre>"},{"location":"core/plugins/making_handlers/#q2-how-does-the-process_plugin-method-work","title":"Q2: How does the <code>process_plugin</code> Method Work?","text":"<p>A2: The <code>process_plugin</code> method is the core function of a Handler. It dictates how each plugin is executed based on its type. This method receives three parameters:</p> <ul> <li><code>plugin</code> (<code>PluginInfo</code>): Metadata and configuration of the plugin to be processed.</li> <li><code>prior_results</code> (<code>list[Result]</code>): Results from previously executed plugins.</li> <li><code>registry</code> (<code>Registry</code>): The central registry managing all plugins.</li> </ul> <p>Functionality:</p> <ol> <li>Identify Plugin Type: Determines the type of the plugin (e.g., <code>input</code>, <code>output</code>).</li> <li>Execute Plugin Logic: Calls the appropriate method on the plugin object based on its type.</li> <li>Return Results: Outputs a list of <code>Result</code> objects for further processing.</li> </ol> <p>Example Implementation:</p> <pre><code>@hookimpl\ndef process_plugin(self, plugin: PluginInfo, prior_results: list[Result], registry: Registry) -&gt; list[Result]:\n    logger.debug(f\"CustomHandler processing plugin {plugin.name}\")\n    if plugin.type == \"transformer\":\n        return plugin.plugin_obj.transform(prior_results)\n    else:\n        logger.warning(f\"Unhandled plugin type: {plugin.type}\")\n        return prior_results\n</code></pre>"},{"location":"core/plugins/making_handlers/#q3-how-do-handlers-interact-with-the-registry-and-plugin-pipeline","title":"Q3: How Do Handlers Interact with the Registry and Plugin Pipeline?","text":"<p>A3: Handlers are integrated into the OpsBox Plugin Pipeline through the <code>Registry</code>. When the <code>Registry</code> initializes, it loads all handlers based on their TOML configurations. During pipeline execution:</p> <ol> <li>Pipeline Production: The <code>Registry</code> compiles an ordered list of active plugins.</li> <li>Handler Invocation: For each plugin, the corresponding Handler's <code>process_plugin</code> method is invoked.</li> <li>Result Management: Handlers process plugins and return <code>Result</code> objects, which are then passed to subsequent plugins as needed.</li> </ol> <p>This interaction ensures that each plugin is executed in the correct context and sequence, maintaining the pipeline's integrity.</p>"},{"location":"core/plugins/making_handlers/#q4-can-handlers-be-specialized-for-specific-plugin-types","title":"Q4: Can Handlers Be Specialized for Specific Plugin Types?","text":"<p>A4: Yes, Handlers can be specialized to manage specific plugin types, enhancing modularity and scalability. For example, a Rego Handler can be created to exclusively manage <code>rego</code> plugins, ensuring that policy compliance checks are handled separately from other plugin types.</p> <p>Example:</p> <pre><code># rego_handler.toml\n[info]\nname = \"rego_handler\"\nmodule = \"rego_handler\"\nclass_name = \"RegoHandler\"\ntype = \"handler\"\n\n[handler]\nhandles = [\"rego\"]\n</code></pre>"},{"location":"core/plugins/making_handlers/#q5-what-should-i-do-if-my-handler-fails-during-execution","title":"Q5: What Should I Do If My Handler Fails During Execution?","text":"<p>A5: If a Handler encounters an error during execution:</p> <ol> <li>Logging: The system logs the error details using <code>loguru</code>, providing insights into what went wrong.</li> <li>Graceful Degradation: Depending on the severity, the system may skip the faulty handler or halt the entire pipeline to prevent inconsistent states.</li> <li>Debugging: Review the logs to identify and address the issue within the Handler's implementation.</li> <li>Retry Mechanism: Implement retry logic within the Handler if appropriate, to handle transient errors.</li> </ol> <p>Best Practice: Always include robust error handling within your Handlers to manage exceptions gracefully and maintain system stability.</p>"},{"location":"core/plugins/making_handlers/#q6-how-can-i-extend-the-handlerspec-with-additional-methods","title":"Q6: How Can I Extend the HandlerSpec with Additional Methods?","text":"<p>A6: To extend the <code>HandlerSpec</code> with additional methods:</p> <ol> <li>Define New Hookspecs:</li> <li>Add new methods annotated with <code>@hookspec</code> in <code>core/base_hooks.py</code>.</li> </ol> <pre><code># core/base_hooks.py\nclass CustomSpec:\n    @hookspec\n    def custom_method(self, data: Any) -&gt; Any:\n        \"\"\"A custom hook method.\"\"\"\n</code></pre> <ol> <li>Register the New Hookspecs:</li> <li>Update the Handler's <code>add_hookspecs</code> method to include the new hookspecs.</li> </ol> <pre><code>@hookimpl\ndef add_hookspecs(self, manager: PluginManager):\n    from core.base_hooks import CustomSpec\n    manager.add_hookspecs(CustomSpec)\n</code></pre> <ol> <li>Implement the New Methods in the Handler:</li> <li>Define the corresponding hook implementations in your Handler class.</li> </ol> <pre><code>@hookimpl\ndef custom_method(self, data: Any) -&gt; Any:\n    # Implement custom logic\n    return processed_data\n</code></pre> <ol> <li>Update Handler Configuration:</li> <li>Ensure that your handler's TOML file and any related configurations accommodate the new methods.</li> </ol>"},{"location":"core/plugins/making_handlers/#q7-can-multiple-handlers-manage-the-same-plugin-type","title":"Q7: Can Multiple Handlers Manage the Same Plugin Type?","text":"<p>A7: While it's technically possible to have multiple Handlers manage the same plugin type, it's generally not recommended as it can lead to conflicts and unpredictable behaviors. Instead, designate a single Handler to manage each plugin type to maintain clarity and control within the pipeline.</p> <p>Recommendation: Ensure that each plugin type is managed by only one Handler to avoid overlapping responsibilities and potential processing issues.</p>"},{"location":"core/plugins/making_outputs/","title":"Creating Output Plugins for Opsbox","text":"<p>Output plugins in Opsbox are designed to process and handle the data collected from provider plugins and formatted by Rego checks. They play a crucial role in the final stage of the pipeline, ensuring that the processed results are delivered to their intended destinations, such as databases, files, or issue tracking systems.</p>"},{"location":"core/plugins/making_outputs/#before-you-start","title":"Before You Start","text":"<p>If you haven't read the Plugin Basics document, please take a moment to do so! It provides essential information for successfully gathering data, including:</p> <ul> <li>Setting up a proper hookimpl marker to register hook implementations</li> <li>Defining expected user configuration values through a Pydantic model</li> <li>Initializing plugin classes through the <code>activate()</code> hook implementation</li> </ul>"},{"location":"core/plugins/making_outputs/#defining-hook-implementations","title":"Defining Hook Implementations","text":"<p>Output plugins implement the hooks from <code>OutputSpec</code>. The key method to implement is <code>process_results(self, results: list[\"Result\"]) -&gt; None</code>.</p>"},{"location":"core/plugins/making_outputs/#hook-specification","title":"Hook Specification","text":"<p>Here is the definition from the <code>OutputSpec</code> class:</p> <pre><code>class OutputSpec:\n    \"\"\"Base contract for outputs.\n    Outputs are plugins that process the data from the providers.\"\"\"\n\n    @hookspec\n    def process_results(self, results: list[\"FormattedResult\"]) -&gt; None:\n        \"\"\"Output the data from the plugin.\"\"\"\n</code></pre>"},{"location":"core/plugins/making_outputs/#example-implementation","title":"Example Implementation","text":"<p>Below is an example implementation of an output plugin that writes results to a text file:</p> <pre><code>from pluggy import HookimplMarker\nfrom core.plugins import Result\nimport os\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass TextFileOutput:\n\n    @hookimpl\n    def process_results(self, results: list[Result]) -&gt; None:\n        \"\"\"\n        Write the formatted results to a text file.\n\n        Args:\n            results (list[FormattedResult]): A list of formatted results to be written to a file.\n        \"\"\"\n        output_directory = \"output_files\"\n        os.makedirs(output_directory, exist_ok=True)\n\n        for result in results:\n            file_path = os.path.join(output_directory, f\"{result['check_name']}.txt\")\n            with open(file_path, \"w\") as file:\n                file.write(result[\"formatted\"])\n</code></pre>"},{"location":"core/plugins/making_outputs/#explanation","title":"Explanation","text":"<ol> <li>Hook Implementation: The <code>process_results</code> method processes a list of <code>Result</code> items.</li> <li>Writing to File: For each formatted result, it creates a text file and writes the check name, description, result, details, and formatted output to the file.</li> <li>Output Directory: Ensures that the output directory exists and writes each result to a separate file.</li> </ol> <p>By following these guidelines, you can create efficient output plugins for Opsbox, ensuring your formatted results are processed and delivered to their intended destinations. Happy coding! \ud83d\ude80</p>"},{"location":"core/plugins/making_providers/","title":"Creating Provider Plugins for OpsBox","text":"<p>Provider plugins are the backbone of OpsBox, enabling the system to gather data from various infrastructure backends such as AWS and Azure (Azure support is not yet implemented). These plugins provide a seamless interface for collecting data, which is then utilized by rego checks and input plugins to enhance functionality and compliance.</p>"},{"location":"core/plugins/making_providers/#before-you-start","title":"Before You Start","text":"<p>Before you begin developing a Provider plugin, it's essential to familiarize yourself with the Plugin Basics documentation. This foundational guide covers:</p> <ul> <li>Setting Up the Hook Implementation Marker: Learn how to register your plugin's hook implementations using Pluggy.</li> <li>Defining User Configuration Values: Utilize Pydantic models to specify and validate the configuration parameters your plugin requires.</li> <li>Initializing Plugin Classes: Implement the <code>activate()</code> hook to initialize your plugin effectively.</li> </ul> <p>Additionally, ensure you have the necessary configuration and client setup to access the service data required by your plugin.</p>"},{"location":"core/plugins/making_providers/#required-hooks","title":"Required Hooks","text":"<p>Provider plugins in OpsBox are specialized plugins that implement the <code>ProviderSpec</code> methods defined within the <code>general</code> handler. The primary method you need to implement is <code>gather_data</code>, which is responsible for collecting data from your services.</p>"},{"location":"core/plugins/making_providers/#hook-specification","title":"Hook Specification","text":"<p>The <code>gather_data</code> method is designed to probe your services for data and return a <code>Result</code> object. This <code>Result</code> serves as the input for subsequent rego checks and input plugins.</p> <pre><code>class ProviderSpec:\n    @hookspec\n    def gather_data(self) -&gt; Result:\n        \"\"\"Gather data for the plugin.\"\"\"\n</code></pre>"},{"location":"core/plugins/making_providers/#example-implementation","title":"Example Implementation","text":"<p>Below is an example from the production <code>ec2</code> plugin's <code>gather_data</code> function. This example demonstrates how to collect data related to AWS EC2 instances, volumes, and Elastic IPs.</p> <pre><code>from pluggy import HookimplMarker\nfrom pydantic import BaseModel, Field\n\nhookimpl = HookimplMarker(\"opsbox\")\n\nclass EC2Provider:\n    ...\n    @hookimpl\n    def gather_data(self):\n        \"\"\"\n        Gathers data related to AWS EC2 instances, volumes, and Elastic IPs.\n\n        Returns:\n            Result: A Result object containing the gathered data in the following format:\n                {\n                    \"input\": {\n                        \"volumes\": [\n                            {\n                                \"volume_id\": \"vol-1234567890abcdef0\",\n                                \"state\": \"available\",\n                                \"size\": 8,\n                                \"create_time\": \"2021-06-01T00:00:00\",\n                                \"region\": \"us-west-1\"\n                            },\n                            ...\n                        ],\n                        \"instances\": [\n                            {\n                                \"instance_id\": \"i-1234567890abcdef0\",\n                                \"state\": \"running\",\n                                \"avg_cpu_utilization\": 0.0,\n                                \"region\": \"us-west-1\"\n                            },\n                            ...\n                        ]\n                    }\n                }\n        \"\"\"\n        # Implementation for gathering data from AWS EC2\n        # Example placeholder implementation\n        data = {\n            \"input\": {\n                \"volumes\": [\n                    {\n                        \"volume_id\": \"vol-1234567890abcdef0\",\n                        \"state\": \"available\",\n                        \"size\": 8,\n                        \"create_time\": \"2021-06-01T00:00:00\",\n                        \"region\": \"us-west-1\"\n                    },\n                    # Additional volume data...\n                ],\n                \"instances\": [\n                    {\n                        \"instance_id\": \"i-1234567890abcdef0\",\n                        \"state\": \"running\",\n                        \"avg_cpu_utilization\": 0.0,\n                        \"region\": \"us-west-1\"\n                    },\n                    # Additional instance data...\n                ]\n            }\n        }\n        result = Result(\n            relates_to=\"EC2Provider\",\n            result_name=\"EC2Data\",\n            result_description=\"Collected data from AWS EC2 instances and volumes.\",\n            details=data,\n            formatted=str(data)\n        )\n        return result\n</code></pre>"},{"location":"core/plugins/making_providers/#plugin-configuration","title":"Plugin Configuration","text":"<p>Each Provider plugin must include a TOML configuration file that provides essential metadata and specifies its dependencies. This configuration ensures that OpsBox can correctly load and manage the plugin.</p>"},{"location":"core/plugins/making_providers/#example-provider_plugintoml","title":"Example <code>provider_plugin.toml</code>","text":"<pre><code>[info]\nname = \"ec2_provider\"\nmodule = \"ec2_provider\"\nclass_name = \"EC2Provider\"\ntype = \"provider\"\nuses = [\"general\"]\n</code></pre> <p>Configuration Breakdown:</p> <ul> <li>[info] Section:</li> <li><code>name</code>: Unique identifier for the plugin (<code>\"ec2_provider\"</code>).</li> <li><code>module</code>: Name of the Python module where the plugin class is defined (<code>\"ec2_provider\"</code>).</li> <li><code>class_name</code>: Name of the plugin class within the module (<code>\"EC2Provider\"</code>).</li> <li><code>type</code>: Specifies the plugin type (<code>\"provider\"</code>), allowing OpsBox to dispatch it to the appropriate handler.</li> <li><code>uses</code>: Lists dependencies required by the plugin (<code>[\"general\"]</code>).</li> </ul>"},{"location":"core/plugins/making_providers/#faqs","title":"FAQs","text":""},{"location":"core/plugins/making_providers/#q1-how-do-provider-plugins-handle-large-data-volumes","title":"Q1: How Do Provider Plugins Handle Large Data Volumes?","text":"<p>A1: Handling large data volumes efficiently is vital for Provider Plugins to maintain performance and prevent bottlenecks. Here are strategies to manage large datasets:</p>"},{"location":"core/plugins/making_providers/#pagination","title":"Pagination:","text":"<p>Retrieve data in manageable chunks rather than all at once to reduce memory consumption.</p> <p>Example:</p> <pre><code>def gather_data(self) -&gt; Result:\n    all_data = []\n    paginator = self.ec2_client.get_paginator('describe_instances')\n    for page in paginator.paginate():\n        all_data.extend(page['Reservations'])\n    return Result(..., details={\"instances\": all_data}, ...)\n</code></pre>"},{"location":"core/plugins/making_providers/#streaming","title":"Streaming:","text":"<p>Stream data directly to consumers or storage to avoid loading everything into memory.</p>"},{"location":"core/plugins/making_providers/#data-filtering","title":"Data Filtering:","text":"<p>Collect only the necessary data by applying filters during the data gathering process.</p> <p>Example:</p> <pre><code>def gather_data(self) -&gt; Result:\n    filters = [{'Name': 'instance-state-name', 'Values': ['running']}]\n    response = self.ec2_client.describe_instances(Filters=filters)\n    # Process filtered data\n    return Result(...)\n</code></pre>"},{"location":"core/plugins/making_providers/#compression","title":"Compression:","text":"<p>Compress data before storing or transmitting to reduce size.</p>"},{"location":"core/plugins/making_providers/#asynchronous-processing","title":"Asynchronous Processing:","text":"<p>Utilize asynchronous programming to handle data gathering tasks concurrently, improving throughput.</p> <p>Example with asyncio:</p> <pre><code>import asyncio\n\nasync def gather_data(self) -&gt; Result:\n    tasks = [self.fetch_data(instance_id) for instance_id in self.instance_ids]\n    results = await asyncio.gather(*tasks)\n    # Aggregate results\n    return Result(...)\n</code></pre>"},{"location":"core/plugins/making_providers/#efficient-data-structures","title":"Efficient Data Structures:","text":"<p>Use optimized data structures and algorithms to process data efficiently.</p>"},{"location":"core/plugins/making_providers/#resource-management","title":"Resource Management:","text":"<p>Monitor and manage system resources (CPU, memory) to prevent overloads during large data operations.</p>"},{"location":"core/plugins/making_providers/#best-practices","title":"Best Practices:","text":"<ul> <li>Benchmarking: Regularly benchmark your data gathering methods to identify and address performance issues.</li> <li>Scalability: Design your Provider Plugins to scale horizontally if necessary, distributing data processing across multiple instances.</li> <li>Monitoring: Implement monitoring to track data processing metrics and detect potential bottlenecks early.</li> </ul>"},{"location":"core/plugins/making_providers/#q2-can-provider-plugins-have-dependencies","title":"Q2: Can Provider Plugins Have Dependencies?","text":"<p>A2: Yes, Provider Plugins can specify dependencies using the <code>uses</code> field in their TOML configuration files. This allows a Provider Plugin to depend on other plugins, such as handlers or additional data sources. Managing dependencies ensures that all required plugins are loaded and initialized in the correct order before the Provider Plugin executes its data gathering logic.</p> <p>Example:</p> <pre><code>[info]\nname = \"ec2_provider\"\nmodule = \"ec2_provider\"\nclass_name = \"EC2Provider\"\ntype = \"provider\"\nuses = [\"general\"]\n</code></pre> <p>In this example, the <code>ec2_provider</code> plugin depends on the general handler and a hypothetical <code>credentials_manager</code> plugin.</p>"},{"location":"core/plugins/making_providers/#q3-can-i-use-multiple-provider-plugins-in-opsbox","title":"Q3: Can I Use Multiple Provider Plugins in OpsBox?","text":"<p>A3: Yes, OpsBox supports the use of multiple Provider Plugins simultaneously. This allows you to gather data from various infrastructure backends within the same pipeline. Each Provider Plugin operates independently, collecting data from its designated source, which can then be utilized by other plugins for processing and compliance checks.</p> <p>Example Scenario:</p> <ul> <li> <p>Provider Plugins:</p> <ul> <li><code>ec2_provider</code>: Gathers data from AWS EC2 instances.</li> <li><code>s3_provider</code>: Gathers data from AWS S3 buckets.</li> </ul> </li> <li> <p>Pipeline Flow:</p> <ul> <li><code>idle_instances</code> collects EC2 data.</li> <li><code>unused_storage</code> collects S3 data.</li> <li>Input Plugins format the data.</li> </ul> </li> </ul>"},{"location":"core/plugins/making_providers/#best-practices_1","title":"Best Practices","text":"<ul> <li>Consistent Naming: Ensure that plugin names are unique and descriptive to avoid conflicts and enhance readability.</li> <li>Secure Credentials: Never hard-code sensitive information like API keys. Use secure methods to inject credentials into your plugin configuration.</li> <li>Comprehensive Documentation: Document your plugin's purpose, configuration options, and any dependencies to aid other developers and users.</li> <li>Error Handling: Implement robust error handling within the <code>gather_data</code> method to gracefully manage failures and provide meaningful log messages.</li> <li>Testing: Rigorously test your Provider plugin to ensure it accurately collects and formats data as expected.</li> </ul> <p>By following this guide, you can effectively create Provider plugins that integrate seamlessly with OpsBox, ensuring reliable data collection and enhancing the overall functionality of your infrastructure management workflows.</p>"},{"location":"core/plugins/plugin_overview/","title":"Opsbox Plugin System Overview","text":"<p>Welcome to Opsbox, where our plugin-based architecture makes cloud infrastructure management seamless and efficient! Let\u2019s dive into how Opsbox uses its flexible plugin system to keep everything composable and extendable.</p>"},{"location":"core/plugins/plugin_overview/#types-of-plugins","title":"Types of Plugins","text":"<p>At the core of Opsbox are handlers, plugins that specify and handle other types of plugins. They implement functions that can handle many plugin types and structures.</p> <p>Right now we have 2 handlers built, the general and rego handlers.</p> <p>Let's go over these handlers and what they can be used for.</p>"},{"location":"core/plugins/plugin_overview/#general-handler","title":"General Handler","text":"<p>These plugins use the general handler, which handles code not specifically related to rego checks and general-use plugins that don't need to define their own hookspecs.</p>"},{"location":"core/plugins/plugin_overview/#1-providers","title":"1. Providers","text":"<p>Providers act as data sources (e.g., EC2, S3, etc.). They gather information from external sources and forward them to plugins that use them.</p>"},{"location":"core/plugins/plugin_overview/#2-inputs","title":"2. Inputs","text":"<p>Inputs can collect data from a plugin and proccess them or produce their own data, but they are always the start of a pipeline. They provide formatted results that other plugins can use.</p>"},{"location":"core/plugins/plugin_overview/#3-assistants","title":"3. Assistants","text":"<p>Assistants process, transform, and enhance the results from inputs. They act as intermediaries, refining the data for better analysis and decision-making.</p>"},{"location":"core/plugins/plugin_overview/#4-outputs","title":"4. Outputs","text":"<p>Outputs handle the final formatted results, directing them to specified destinations (e.g., Jira, text files, etc.).</p>"},{"location":"core/plugins/plugin_overview/#rego-handler","title":"Rego Handler","text":"<p>Allows for connection and proccessing of rego-formatted inputs called rego checks into the pipeline. Rego-based plugins use the Open Policy Agent to execute and gather details from associated rego code. </p>"},{"location":"core/plugins/plugin_overview/#check","title":"Check","text":"<p>A rego check collects data from a provider and executes given rego code on that data using a trusted OPA server.</p> <p>By combining these plugin types, you can create a seamless pipeline for automatically generating and managing cloud infrastructure.</p>"},{"location":"core/plugins/plugin_overview/#building-a-pipeline","title":"Building a Pipeline","text":"<p>A pipeline in Opsbox is a series of plugins executed in a defined sequence to produce desired outcomes. Each pipeline consists of three main components:</p>"},{"location":"core/plugins/plugin_overview/#1-input-plugins","title":"1. Input Plugins","text":"<p>These are the primary inputs/checks you want to run. They form the foundation of your analysis and are specified as a comma-separated list in the first argument.</p>"},{"location":"core/plugins/plugin_overview/#2-assistants","title":"2. Assistants","text":"<p>These plugins process the results from the input results. They are executed in left-to-right order, refining and expanding upon the data.</p>"},{"location":"core/plugins/plugin_overview/#3-outputs","title":"3. Outputs","text":"<p>Outputs handle the final results, directing them to their intended destinations. These are also specified as a comma-separated list.</p>"},{"location":"core/plugins/plugin_overview/#pipeline-definition-format","title":"Pipeline Definition Format","text":"<p>Pipelines are defined using the following format: <pre><code>check_1,check_2-assistant_1-assistant_2-output_1,output_2\n</code></pre></p>"},{"location":"core/plugins/plugin_overview/#example-pipeline","title":"Example Pipeline","text":"<p>Suppose we want to analyze idle EC2 instances, have an OpenAI assistant provide cost-saving recommendations, and output the results to Jira and a text file. Our pipeline would look like this: <pre><code>idle_instances-cost_savings-text_file,jira\n</code></pre></p> <p>In this example:</p> <ul> <li><code>idle_instances</code> is our Rego check input.</li> <li><code>cost_savings</code> is our cost-analyzing assistant.</li> <li><code>text_file,jira</code> are our output destinations.</li> </ul> <p>With Opsbox\u2019s flexible plugin system, you can create powerful, automated pipelines tailored to your cloud infrastructure needs! \ud83d\ude80</p>"},{"location":"core/testing/testing/","title":"Testing Plugins and Handlers in OpsBox Using Pytest","text":"<p>This document provides an overview of how to test plugins, handlers, and the plugin registry in OpsBox using <code>pytest</code>. It includes details about the test directory structure, running tests, generating coverage reports, and writing new tests.</p>"},{"location":"core/testing/testing/#directory-structure","title":"Directory Structure","text":"<p>The testing framework is organized into different categories focusing on configuration, handlers, and registry management:</p> <pre><code>test/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 rego_handler/              # Placeholder for rego-specific handler tests\n\u2502   \u251c\u2500\u2500 conftest.py                # Shared test configurations and fixtures\n\u2502   \u251c\u2500\u2500 test_file_finding.py       # Tests for finding plugin configuration files\n\u2502   \u251c\u2500\u2500 test_loading.py            # Tests for loading plugins and configs\n\u2502   \u2514\u2500\u2500 test_property_access.py    # Tests for accessing plugin properties post-loading\n\u251c\u2500\u2500 general_handler/\n\u2502   \u2514\u2500\u2500 test_hooks.py              # Tests for general plugin handler hooks\n\u251c\u2500\u2500 registry/\n\u2502   \u2514\u2500\u2500 test_registry.py           # Tests for the plugin registry (loading, activating)\n\u2514\u2500\u2500 test_plugins.py                # Tests for overall plugin functionality\n</code></pre>"},{"location":"core/testing/testing/#key-areas-covered","title":"Key Areas Covered","text":"<ul> <li>Config Tests (<code>config/</code>): Focus on configuration file loading, plugin file management, and property access.</li> <li>General Handler Tests (<code>general_handler/</code>): Validate hook implementations and their interactions in the general plugin handler.</li> <li>Registry Tests (<code>registry/</code>): Ensure the plugin registry manages loading, activating, and handling plugins correctly.</li> <li>Plugin Functionality Tests (<code>test_plugins.py</code>): Validate that plugins work as expected when integrated into the system.</li> </ul>"},{"location":"core/testing/testing/#running-tests","title":"Running Tests","text":""},{"location":"core/testing/testing/#running-all-tests","title":"Running All Tests","text":"<p>To run all tests in the OpsBox project:</p> <pre><code>pytest\n</code></pre>"},{"location":"core/testing/testing/#running-specific-tests","title":"Running Specific Tests","text":"<p>To run a specific test file, for example, registry tests:</p> <pre><code>pytest test/registry/test_registry.py\n</code></pre> <p>To run a specific test function in a file:</p> <pre><code>pytest test/general_handler/test_hooks.py::test_some_function\n</code></pre>"},{"location":"core/testing/testing/#common-pytest-options","title":"Common Pytest Options","text":"<ul> <li> <p>Verbose Output: <pre><code>pytest -v\n</code></pre></p> </li> <li> <p>Stop on First Failure: <pre><code>pytest -x\n</code></pre></p> </li> </ul> <p>For more information on running tests and pytest options, see the pytest documentation.</p>"},{"location":"core/testing/testing/#generating-coverage-reports","title":"Generating Coverage Reports","text":"<p>To generate a coverage report for the tests, install the <code>pytest-cov</code> plugin if it's not already installed:</p> <pre><code>uv add pytest-cov\n</code></pre> <p>Then, run the tests with coverage enabled:</p> <pre><code>pytest --cov=&lt;source_directory&gt; --cov-report=html\n</code></pre> <p>This generates an HTML coverage report in the <code>htmlcov</code> directory. You can then view the report to see how much of your code is covered by tests.</p> <p>Example for OpsBox:</p> <pre><code>pytest --cov=opsbox --cov-report=html\n</code></pre> <p>For more details, see the pytest-cov documentation.</p>"},{"location":"core/testing/testing/#conclusion","title":"Conclusion","text":"<p>By following this guide, you can run, extend, and create new tests for your OpsBox project using <code>pytest</code>. This ensures that all plugins, handlers, and registries are functioning as expected across different scenarios.</p> <p>For more detailed information on writing tests in pytest, visit the official pytest documentation.</p> <p>Let me know if you'd like any more modifications!</p>"},{"location":"core/testing/testing_general_plugins/","title":"Testing General Handler Plugin Types in OpsBox Using Pytest","text":"<p>This document will guide you through testing general handler plugin types, including input, output, and provider plugins, using the provided <code>MockPlugin</code> and <code>MockConfig</code> utilities. We will cover how to set up and run tests, and provide examples for each plugin type.</p>"},{"location":"core/testing/testing_general_plugins/#overview","title":"Overview","text":"<p>The General Handler in OpsBox is responsible for managing different plugin types, such as input, output, and provider plugins. When testing these plugins, it is important to verify that:</p> <ul> <li>Hooks are properly registered and implemented for each plugin type.</li> <li>Data processing functions correctly for input, output, and provider plugins.</li> <li>Configurations are loaded correctly and the plugins interact as expected with the OpsBox system.</li> </ul> <p>This document will demonstrate how to use the provided mock utilities and <code>pytest</code> to test these plugin types.</p>"},{"location":"core/testing/testing_general_plugins/#mocks","title":"Mocks","text":"<p>We will use the following mocks to facilitate testing:</p> <ul> <li><code>MockPlugin</code>: Produces a mock plugin object with a given type, class, and configuration.</li> <li><code>MockConfig</code>: Creates a mock configuration file for testing, combining overrides and base configuration.</li> </ul>"},{"location":"core/testing/testing_general_plugins/#plugin-types-tested","title":"Plugin Types Tested:","text":"<ol> <li>Input Plugin: Processes incoming data and passes it to the next stage in the pipeline.</li> <li>Output Plugin: Processes the results from other plugins and outputs the final result.</li> <li>Provider Plugin: Gathers data from an external source (e.g., AWS, databases) and makes it available for further processing.</li> </ol>"},{"location":"core/testing/testing_general_plugins/#setting-up-the-test-environment","title":"Setting Up the Test Environment","text":"<p>First, ensure that <code>pytest</code> is installed:</p> <pre><code>uv add pytest\n</code></pre> <p>Ensure your project and mocks are properly set up. Then, use the provided <code>MockPlugin</code> and <code>MockConfig</code> functions to simulate plugins and configurations.</p>"},{"location":"core/testing/testing_general_plugins/#example-test-for-input-plugins","title":"Example Test for Input Plugins","text":"<p>Input plugins are responsible for processing incoming data and passing it along the pipeline.</p>"},{"location":"core/testing/testing_general_plugins/#example-hook-specification-if-needed","title":"Example Hook Specification (if needed):","text":"<pre><code>class InputSpec:\n    \"\"\"Base contract for input plugins.\"\"\"\n\n    @hookspec\n    def process(self, data: list[Result]) -&gt; list[Result]:\n        \"\"\"Process input data.\"\"\"\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#test-for-input-plugin","title":"Test for Input Plugin","text":"<pre><code>import pytest\nfrom core.plugins import PluginInfo, Result\nfrom general_handler import GeneralHandler\nfrom mock_plugin_utils import MockPlugin, MockConfig\n\nclass ExampleInputPlugin:\n    \"\"\"A simple input plugin that processes data.\"\"\"\n\n    def grab_config(self):\n        return ExampleInputConfig\n\n    def set_data(self, config):\n        self.config = config\n\n    def process(self, data: list[Result]) -&gt; list[Result]:\n        \"\"\"Simple data processor.\"\"\"\n        return [{\"processed_data\": \"processed_\" + item[\"input_data\"]} for item in data]\n\nclass ExampleInputConfig(BaseModel):\n    input_data_key: str\n\ndef test_input_plugin():\n    \"\"\"Test that the input plugin processes data correctly.\"\"\"\n\n    # Mock the plugin configuration\n    mock_config = {\n        \"input_data_key\": \"input_data\"\n    }\n\n    # Create a mock input plugin\n    plugin = MockPlugin(ExampleInputPlugin, \"input\", mock_config)\n\n    # Create a mock general handler\n    handler = GeneralHandler()\n\n    # Mock input data\n    data = [{\"input_data\": \"raw_data\"}]\n\n    # Process the input plugin using the handler\n    results = handler.process_plugin(plugin, data, registry=None)\n\n    assert results == [{\"processed_data\": \"processed_raw_data\"}]\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#explanation","title":"Explanation","text":"<ul> <li>MockPlugin: Creates a mock input plugin with the specified configuration.</li> <li>process_plugin: This test simulates the input plugin processing some data and checks if the output is correct.</li> </ul>"},{"location":"core/testing/testing_general_plugins/#example-test-for-output-plugins","title":"Example Test for Output Plugins","text":"<p>Output plugins receive processed results and usually present them in a specific format or send them to a destination.</p>"},{"location":"core/testing/testing_general_plugins/#example-hook-specification-if-needed_1","title":"Example Hook Specification (if needed):","text":"<pre><code>class OutputSpec:\n    \"\"\"Base contract for output plugins.\"\"\"\n\n    @hookspec\n    def process_results(self, results: list[Result]) -&gt; None:\n        \"\"\"Process and output the results.\"\"\"\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#test-for-output-plugin","title":"Test for Output Plugin","text":"<pre><code>class ExampleOutputPlugin:\n    \"\"\"A simple output plugin that processes results.\"\"\"\n\n    def grab_config(self):\n        return ExampleOutputConfig\n\n    def set_data(self, config):\n        self.config = config\n\n    def process_results(self, results: list[Result]) -&gt; None:\n        \"\"\"Simulates sending processed results somewhere.\"\"\"\n        # Just print the results for this test case (or log them)\n        for result in results:\n            print(f\"Output: {result['processed_data']}\")\n\nclass ExampleOutputConfig(BaseModel):\n    output_target: str\n\ndef test_output_plugin(mocker):\n    \"\"\"Test that the output plugin processes results correctly.\"\"\"\n\n    # Mock configuration\n    mock_config = {\n        \"output_target\": \"console\"\n    }\n\n    # Create a mock output plugin\n    plugin = MockPlugin(ExampleOutputPlugin, \"output\", mock_config)\n\n    # Mock the general handler\n    handler = GeneralHandler()\n\n    # Mock processed results from prior steps\n    processed_data = [{\"processed_data\": \"final_data\"}]\n\n    # Mock print function (or logging) to capture output\n    mocker.patch(\"builtins.print\")\n\n    # Process the output plugin\n    handler.process_plugin(plugin, processed_data, registry=None)\n\n    # Verify that the correct output was produced\n    print.assert_called_with(\"Output: final_data\")\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#explanation_1","title":"Explanation","text":"<ul> <li>MockPlugin: Creates a mock output plugin with a basic configuration.</li> <li>process_plugin: Simulates the output plugin processing and printing the final results.</li> <li>mocker: Used to capture the <code>print</code> output (you can also use logging or other methods).</li> </ul>"},{"location":"core/testing/testing_general_plugins/#example-test-for-provider-plugins","title":"Example Test for Provider Plugins","text":"<p>Provider plugins gather data from external sources, such as APIs or databases, and make it available to the rest of the pipeline.</p>"},{"location":"core/testing/testing_general_plugins/#example-hook-specification-if-needed_2","title":"Example Hook Specification (if needed):","text":"<pre><code>class ProviderSpec:\n    \"\"\"Base contract for provider plugins.\"\"\"\n\n    @hookspec\n    def gather_data(self) -&gt; Result:\n        \"\"\"Gathers data from external sources.\"\"\"\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#test-for-provider-plugin","title":"Test for Provider Plugin","text":"<pre><code>class ExampleProviderPlugin:\n    \"\"\"A simple provider plugin that gathers data.\"\"\"\n\n    def grab_config(self):\n        return ExampleProviderConfig\n\n    def set_data(self, config):\n        self.config = config\n\n    def gather_data(self) -&gt; Result:\n        \"\"\"Simulates gathering data from an external source.\"\"\"\n        return {\"gathered_data\": \"external_data\"}\n\nclass ExampleProviderConfig(BaseModel):\n    api_key: str\n\ndef test_provider_plugin():\n    \"\"\"Test that the provider plugin gathers data correctly.\"\"\"\n\n    # Mock configuration for the provider plugin\n    mock_config = {\n        \"api_key\": \"mock_api_key\"\n    }\n\n    # Create a mock provider plugin\n    plugin = MockPlugin(ExampleProviderPlugin, \"provider\", mock_config)\n\n    # Process the provider plugin and gather data\n    result = plugin.plugin_obj.gather_data()\n\n    # Assert that the gathered data is correct\n    assert result == {\"gathered_data\": \"external_data\"}\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#explanation_2","title":"Explanation","text":"<ul> <li>MockPlugin: Creates a mock provider plugin that simulates gathering data from an external source.</li> <li>process_plugin: Simulates the provider plugin gathering data and returning it for further processing.</li> </ul>"},{"location":"core/testing/testing_general_plugins/#running-the-tests","title":"Running the Tests","text":"<p>You can run all of these tests using <code>pytest</code>. For example, to run the entire test suite:</p> <pre><code>pytest\n</code></pre> <p>Or to run a specific test file:</p> <pre><code>pytest test/test_input_plugin.py\n</code></pre> <p>You can also run specific test functions:</p> <pre><code>pytest test/test_input_plugin.py::test_input_plugin\n</code></pre>"},{"location":"core/testing/testing_general_plugins/#conclusion","title":"Conclusion","text":"<p>By using the provided <code>MockPlugin</code> and <code>MockConfig</code>, you can easily simulate various plugins (input, output, and provider) and their interactions with the OpsBox system. The tests in this guide demonstrate how to ensure these plugins function correctly in the context of the general handler.</p>"},{"location":"core/testing/testing_handlers/","title":"Testing Handlers","text":""},{"location":"core/testing/testing_handlers/#creating-new-tests-for-handlers","title":"Creating New Tests for Handlers","text":"<p>When writing new tests for handlers, ensure that you cover the following components:</p> <ol> <li>Hook Registration: Test that the handler correctly registers and processes hooks from plugins.</li> <li>Process Plugin Logic: Verify that the <code>process_plugin</code> method works correctly and invokes the appropriate plugin functionality based on the plugin type.</li> <li>Plugin Loading: Ensure that the handler can load and manage plugins correctly.</li> </ol>"},{"location":"core/testing/testing_handlers/#example-test-for-handler-hook","title":"Example: Test for Handler Hook","text":"<pre><code>import pytest\nfrom pluggy import PluginManager\nfrom opsbox.general_handler import GeneralHandler\n\n@pytest.fixture\ndef plugin_manager():\n    \"\"\"Fixture for setting up the plugin manager.\"\"\"\n    manager = PluginManager(\"opsbox\")\n    return manager\n\ndef test_add_hookspecs(plugin_manager):\n    \"\"\"Test that the handler correctly registers hooks.\"\"\"\n    handler = GeneralHandler()\n    handler.add_hookspecs(plugin_manager)\n    assert plugin_manager.get_hookspecs() is not None\n</code></pre>"},{"location":"core/testing/testing_handlers/#example-test-for-process_plugin","title":"Example: Test for <code>process_plugin</code>","text":"<pre><code>def test_process_plugin(plugin_manager):\n    \"\"\"Test that the handler processes plugins correctly.\"\"\"\n    handler = GeneralHandler()\n    plugin = MockPlugin(type=\"input\")\n    handler.process_plugin(plugin, prior_results=[], registry=MockRegistry())\n    assert plugin.was_processed == True\n</code></pre> <p>In this example, <code>MockPlugin</code> is a class from the <code>tests/mocks.py</code> file used to simulate plugins in the sysyem.</p>"},{"location":"core/testing/testing_handlers/#running-your-new-tests","title":"Running Your New Tests","text":"<p>After creating new tests, you can run them just like any other test:</p> <pre><code>pytest test/general_handler/test_hooks.py\n</code></pre>"},{"location":"core/testing/testing_rego_plugins/","title":"Guide for Testing Plugins That Use the Rego Handler in OpsBox","text":"<p>This guide explains how to test plugins that use the Rego handler in OpsBox using <code>pytest</code>. Rego plugins are designed to apply policy checks written in Rego, using Open Policy Agent (OPA) to evaluate data gathered by provider plugins. The Rego handler manages the execution of these Rego plugins, including policy uploads, evaluation, and result formatting.</p> <p>We will cover testing both the Rego handler and plugins that use it, utilizing mocks and test fixtures to simulate the execution of Rego policies in a controlled environment.</p>"},{"location":"core/testing/testing_rego_plugins/#key-concepts","title":"Key Concepts","text":"<p>When testing plugins that use the Rego handler, focus on these key aspects:</p> <ol> <li>Rego Policy Execution: Ensure the plugin runs its Rego policy file using OPA and applies the check on the given data.</li> <li>Provider Data Handling: Test that the plugin correctly gathers data from the provider plugins before running the policy checks.</li> <li>Rego Policy Upload and Cleanup: Verify that the Rego handler uploads policies to OPA before applying the checks and removes them after the check.</li> <li>Result Formatting: Confirm that the results of the policy checks are processed and formatted as expected.</li> </ol>"},{"location":"core/testing/testing_rego_plugins/#testing-setup","title":"Testing Setup","text":"<p>Before running tests, make sure <code>pytest</code> is installed:</p> <pre><code>uv add pytest\n</code></pre> <p>You will also need the following utilities to mock plugin interactions:</p> <ul> <li><code>MockPlugin</code>: Simulates plugin behavior, including configuration and data handling.</li> <li><code>MockConfig</code>: Simulates configuration data for testing.</li> <li><code>MockRegistry</code>: Simulates the OpsBox registry, allowing you to test how Rego plugins gather data from provider plugins.</li> </ul>"},{"location":"core/testing/testing_rego_plugins/#example-rego-plugin","title":"Example Rego Plugin","text":"<p>Here\u2019s a basic Rego plugin that applies a compliance check using a Rego policy file.</p>"},{"location":"core/testing/testing_rego_plugins/#rego-plugin-code","title":"Rego Plugin Code","text":"<pre><code>class ComplianceRegoPlugin:\n    \"\"\"A Rego plugin that applies compliance checks.\"\"\"\n\n    def grab_config(self):\n        return ComplianceRegoConfig\n\n    def set_data(self, config):\n        \"\"\"Set configuration data for the Rego plugin.\"\"\"\n        self.config = config\n\n    def report_findings(self, result: Result) -&gt; Result:\n        \"\"\"Format and report the findings from the Rego check.\"\"\"\n        result.formatted = f\"Compliance check {self.config.rego_file}: {result.result_description}\"\n        return result\n\nclass ComplianceRegoConfig(BaseModel):\n    rego_file: str\n    description: str\n</code></pre> <p>This plugin uses a Rego policy file (<code>rego_file</code>) to apply compliance checks and formats the result with <code>report_findings</code>.</p>"},{"location":"core/testing/testing_rego_plugins/#testing-rego-plugin-using-the-rego-handler","title":"Testing Rego Plugin Using the Rego Handler","text":"<p>We will create tests to validate the entire flow of the Rego plugin using the Rego handler, including:</p> <ul> <li>Gathering data from a provider.</li> <li>Applying a Rego policy.</li> <li>Formatting the results.</li> </ul>"},{"location":"core/testing/testing_rego_plugins/#example-test-running-a-rego-plugin-with-provider-data","title":"Example Test: Running a Rego Plugin with Provider Data","text":"<p>This test simulates how a Rego plugin gathers data from a provider plugin and applies a compliance check using the Rego handler.</p> <pre><code>import pytest\nfrom core.plugins import Result, PLuginFlow\nfrom rego_handler import RegoHandler\nfrom tests.mocks import MockPlugin, MockConfig\n\nclass MockProviderPlugin:\n    \"\"\"A mock provider plugin that gathers data.\"\"\"\n\n    def grab_config(self):\n        return ProviderConfig\n\n    def set_data(self, config):\n        self.config = config\n\n    def gather_data(self):\n        \"\"\"Simulates gathering data from an external source.\"\"\"\n        return Result(\n            relates_to=\"provider\",\n            result_name=\"ProviderData\",\n            result_description=\"Gathered data from provider\",\n            details={\"is_compliant\": {\"status\": \"compliant\"}},\n            formatted=\"\"\n        )\n\nclass ProviderConfig(BaseModel):\n    api_key: str\n\ndef test_compliance_rego_plugin():\n    \"\"\"Test the Rego plugin with provider data.\"\"\"\n\n    # Mock the Rego plugin configuration\n    mock_rego_extra = {\n        \"rego\":{\n            \"rego_file\": \"compliance_policy.rego\",\n            \"description\": \"Check compliance of provider data\"\n        }\n    }\n\n    # Mock the provider plugin configuration\n    mock_provider_config = {\n        \"api_key\": \"mock_api_key\"\n    }\n\n    # Create a mock provider plugin\n    provider_plugin = MockPlugin(\n        MockProviderPlugin, \n        \"provider\", \n        mock_provider_config\n        )\n\n    # Create a mock Rego plugin\n    rego_plugin = MockPlugin(\n        ComplianceRegoPlugin, \n        \"rego\", \n        {},\n        uses = [provider_plugin.name],\n        extra = mock_rego_extra\n        )\n\n    # Mock the Rego handler\n    handler = RegoHandler()\n\n    # make a fake plugin flow\n    mock_flow = PluginFlow(input_plugins=[rego_plugin.name])\n\n    # Mock registry with provider plugin\n    mock_registry = MockRegistry(flow = mock_flow, plugins = [provider_plugin,])\n\n    # Step 1: Run the Rego plugin to check compliance on provider data\n    results = handler.process_plugin(rego_plugin, [], mock_registry)\n\n    # Assert the results of the policy check\n    assert results[0].result_name == \"provider\" \n    assert results[0].details == {\"compliance_data\": {\"status\": \"compliant\"}}\n    assert results[0].formatted == \"Compliance check compliance_policy.rego: Check compliance of provider data\"\n</code></pre>"},{"location":"core/testing/testing_rego_plugins/#explanation","title":"Explanation","text":"<ul> <li>MockPlugin: We use <code>MockPlugin</code> to simulate both the provider plugin (which gathers data) and the Rego plugin (which applies the policy).</li> <li>MockRegistry: Simulates the registry that contains the provider plugin, allowing the Rego handler to access the provider's data.</li> <li>handler.process_plugin: This method is the key function being tested. It triggers the Rego plugin to gather data from the provider and apply the Rego policy.</li> </ul>"},{"location":"core/testing/testing_rego_plugins/#expected-output","title":"Expected Output","text":"<p>The Rego plugin should gather data from the provider and apply the compliance policy. It will format the result based on the findings and return a compliant or non-compliant result.</p>"},{"location":"core/testing/testing_rego_plugins/#testing-rego-policy-upload-and-removal","title":"Testing Rego Policy Upload and Removal","text":"<p>We need to verify that the Rego policy is correctly uploaded to OPA before the check and removed after the check.</p>"},{"location":"core/testing/testing_rego_plugins/#example-test-policy-upload-and-cleanup","title":"Example Test: Policy Upload and Cleanup","text":"<pre><code>from unittest import mock\nimport requests\n\ndef test_rego_policy_upload_and_cleanup(mocker):\n    \"\"\"Test that the Rego policy is uploaded and removed from OPA correctly.\"\"\"\n\n    # Mock Rego handler configuration\n    mock_rego_config = {\n        \"opa_upload_url\": \"http://localhost:8181/v1/policies\",\n        \"opa_apply_url\": \"http://localhost:8181/v1/data\"\n    }\n\n    # Mock Rego plugin\n    rego_plugin = MockPlugin(ComplianceRegoPlugin, \"rego\", {\"rego_file\": \"compliance_policy.rego\", \"description\": \"Compliance check\"})\n\n    # Create the Rego handler and set its config\n    handler = RegoHandler()\n    handler.set_data(mock_rego_config)\n\n    # Mock the OPA policy upload and delete requests\n    mocker.patch(\"requests.put\", return_value=mock.Mock(status_code=200))\n    mocker.patch(\"requests.delete\", return_value=mock.Mock(status_code=200))\n\n    # Use temp_policy to simulate policy upload and cleanup\n    with handler.temp_policy(rego_plugin.extra[\"rego\"], Path(\"/path/to/compliance_policy.rego\"), handler.config.opa_upload_url):\n        pass  # Simulate applying the policy\n\n    # Assert that the policy was uploaded\n    requests.put.assert_called_once_with(\n        \"http://localhost:8181/v1/policies/compliance_policy\",\n        data=mock.ANY,\n        headers={\"Content-Type\": \"text/plain\"},\n        timeout=20\n    )\n\n    # Assert that the policy was removed\n    requests.delete.assert_called_once_with(\n        \"http://localhost:8181/v1/policies/compliance_policy\",\n        headers={\"Content-Type\": \"text/plain\"},\n        timeout=20\n    )\n</code></pre>"},{"location":"core/testing/testing_rego_plugins/#explanation_1","title":"Explanation","text":"<ul> <li>Mock OPA Requests: We mock OPA API requests (<code>requests.put</code> and <code>requests.delete</code>) to simulate the upload and removal of Rego policies.</li> <li>temp_policy: This context manager in the handler is tested to ensure that the policy is uploaded before use and deleted after the check.</li> </ul>"},{"location":"core/testing/testing_rego_plugins/#expected-output_1","title":"Expected Output","text":"<p>The policy should be successfully uploaded and then removed after the Rego check is completed.</p>"},{"location":"core/testing/testing_rego_plugins/#running-the-tests","title":"Running the Tests","text":"<p>To run all the tests for plugins that use the Rego handler, use:</p> <pre><code>pytest\n</code></pre> <p>You can run specific tests with:</p> <pre><code>pytest test/test_compliance_rego_plugin.py\n</code></pre> <p>You can also run specific functions in a test file:</p> <pre><code>pytest test/test_compliance_rego_plugin.py::test_compliance_rego_plugin\n</code></pre>"},{"location":"core/testing/testing_rego_plugins/#conclusion","title":"Conclusion","text":"<p>In this guide, we demonstrated how to:</p> <ol> <li>Test Rego plugins using the Rego handler, verifying that they can apply policies and gather data from provider plugins.</li> <li>Test Rego policy uploads and cleanup, ensuring that policies are correctly handled by OPA before and after checks.</li> <li>Use mocks like <code>MockPlugin</code>, <code>MockRegistry</code>, and <code>MockConfig</code> to simulate plugin behavior and test interactions with the Rego handler.</li> </ol> <p>These tests ensure that Rego plugins function as expected in the OpsBox pipeline, correctly applying policies to data and formatting results in compliance checks.</p>"},{"location":"plugins/","title":"Opsbox Plugins","text":"<p>Welcome to the Opsbox plugins directory. This repository contains a collection of plugins designed to extend the functionality of Opsbox. Each plugin is defined in its own <code>pyproject.toml</code> file, which specifies the dependencies required for that plugin.</p>"},{"location":"plugins/#installing-plugins","title":"Installing Plugins","text":""},{"location":"plugins/#through-pypi","title":"Through PyPI","text":"<p>Most of the packages in this directory are already distributed! Simply download them from PyPI, using the package name desired.</p> <p>To install in UV, simply do the following:</p> <p><code>uv add opsbox-&lt;package-name&gt;</code></p>"},{"location":"plugins/#local-build","title":"Local Build","text":"<ol> <li>Sync UV environment</li> <li>Run build.py</li> <li>Enjoy dists!</li> </ol>"},{"location":"plugins/#sync-uv-environment","title":"Sync UV environment","text":"<p>To begin, we first need to have a good testing/build environment.</p> <p>In the root of the git directory, run <code>uv sync</code>. This will install everything needed.</p>"},{"location":"plugins/#run-buildpy","title":"Run build.py","text":"<p>Next, run the bulk build script using <code>uv run build.py</code></p>"},{"location":"plugins/#enjoy","title":"Enjoy!","text":"<p>The build script will copy all the distributions to the root /dist folder.</p> <p>Enjoy your distributions!</p>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":"<p>This repository contains various types of plugins, each serving a different purpose within Opsbox:</p> <ul> <li>Assistants: These plugins provide recommendations and strategies based on gathered data.</li> <li>AWS Plugins: These plugins offer checks and functionalities specific to AWS services.</li> <li>Handlers: These plugins handle various types of operations within Opsbox.</li> <li>Outputs: These plugins define different output formats for Opsbox results.</li> </ul>"},{"location":"plugins/#using-plugins-with-opsbox","title":"Using Plugins with Opsbox","text":""},{"location":"plugins/#packages","title":"Packages","text":"<p>Packages are autodetected by opsbox if they are in the same environment.</p>"},{"location":"plugins/#individual-modules","title":"Individual Modules","text":"<p>Once you have installed the necessary dependencies for the plugins in OpsBox's , you can point the main Opsbox program to this directory using the <code>--plugin_dir</code> option. Ensure you have installed the prerequisites for Opsbox before proceeding.</p> <pre><code>main.py ... --plugin_dir path/to/this/repository\n</code></pre> <p>This will allow Opsbox to load and utilize the plugins contained in this directory.</p>"},{"location":"plugins/#conclusion","title":"Conclusion","text":"<p>This directory provides a comprehensive set of plugins to enhance the capabilities of Opsbox. By following the installation instructions and pointing Opsbox to this directory, you can leverage these plugins to optimize your operations.</p> <p>For more information, refer to the individual plugin documentation and the Opsbox main documentation.</p>"},{"location":"plugins/ec2/ec2_old_snapshots/","title":"Old EC2 Snapshots Plugin","text":""},{"location":"plugins/ec2/ec2_old_snapshots/#overview","title":"Overview","text":"<p>The Old EC2 Snapshots Plugin identifies EC2 snapshots that are older than a specified period, helping to optimize storage costs by identifying snapshots that can be deleted or archived.</p>"},{"location":"plugins/ec2/ec2_old_snapshots/#key-features","title":"Key Features","text":"<ul> <li>AWS EC2 Integration: Fetches and processes data from AWS EC2.</li> <li>Cost Savings Recommendations: Identifies old snapshots that can be deleted or archived to save costs.</li> <li>Detailed Analysis: Provides detailed information on old EC2 snapshots.</li> </ul>"},{"location":"plugins/ec2/ec2_old_snapshots/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/ec2/ec2_old_snapshots/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/ec2/ec2_old_snapshots/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/ec2/idle_instances/","title":"Idle Instances Plugin","text":""},{"location":"plugins/ec2/idle_instances/#overview","title":"Overview","text":"<p>The Idle Instances Plugin identifies EC2 instances that are running but have low utilization, helping to reduce costs by stopping or terminating these instances.</p>"},{"location":"plugins/ec2/idle_instances/#key-features","title":"Key Features","text":"<ul> <li>AWS EC2 Integration: Fetches and processes data from AWS EC2.</li> <li>Cost Savings Recommendations: Identifies instances that can be stopped or terminated to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/ec2/idle_instances/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/ec2/idle_instances/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/ec2/idle_instances/#default-settings","title":"Default Settings","text":"<ul> <li>Idle threshold: 5% utilization</li> </ul>"},{"location":"plugins/ec2/idle_instances/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/ec2/stray_ebs/","title":"Stray EBS Volumes Plugin","text":""},{"location":"plugins/ec2/stray_ebs/#overview","title":"Overview","text":"<p>The Stray EBS Volumes Plugin identifies EBS volumes that are not attached to any instances, helping to reduce costs by deleting unused volumes.</p>"},{"location":"plugins/ec2/stray_ebs/#key-features","title":"Key Features","text":"<ul> <li>AWS EC2 Integration: Fetches and processes data from AWS EC2.</li> <li>Cost Savings Recommendations: Identifies EBS volumes that can be deleted to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/ec2/stray_ebs/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/ec2/stray_ebs/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/ec2/stray_ebs/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/ec2/stray_instances/","title":"Stray Instances Plugin","text":""},{"location":"plugins/ec2/stray_instances/#overview","title":"Overview","text":"<p>The Stray Instances Plugin identifies EC2 instances that are not associated with any specific workload or application, helping to reduce costs by terminating unused instances.</p>"},{"location":"plugins/ec2/stray_instances/#key-features","title":"Key Features","text":"<ul> <li>AWS EC2 Integration: Fetches and processes data from AWS EC2.</li> <li>Cost Savings Recommendations: Identifies instances that can be terminated to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/ec2/stray_instances/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/ec2/stray_instances/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/ec2/stray_instances/#default-settings","title":"Default Settings","text":"<ul> <li>Period: 300 seconds (5 minutes)</li> <li>Stat: Average</li> <li>ScanBy: TimestampDescending</li> </ul>"},{"location":"plugins/ec2/stray_instances/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/ec2/unattached_eips/","title":"Unattached EIPs Plugin","text":""},{"location":"plugins/ec2/unattached_eips/#overview","title":"Overview","text":"<p>The Unattached EIPs Plugin identifies Elastic IPs (EIPs) that are not associated with any running instances, helping to reduce costs by releasing unused EIPs.</p>"},{"location":"plugins/ec2/unattached_eips/#key-features","title":"Key Features","text":"<ul> <li>AWS EC2 Integration: Fetches and processes data from AWS EC2.</li> <li>Cost Savings Recommendations: Identifies EIPs that can be released to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/ec2/unattached_eips/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/ec2/unattached_eips/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/ec2/unattached_eips/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/elb/high_error_rate/","title":"High Error Rate Load Balancers","text":""},{"location":"plugins/elb/high_error_rate/#overview","title":"Overview","text":"<p>The High Error Rate Load Balancers check identifies load balancers with a high error rate.</p>"},{"location":"plugins/elb/high_error_rate/#key-features","title":"Key Features","text":"<ul> <li>AWS ELB Integration: Fetches and processes data from AWS ELB.</li> <li>Error Rate Analysis: Identifies load balancers with high error rates.</li> <li>Performance Insights: Provides detailed analysis on performance metrics.</li> </ul>"},{"location":"plugins/elb/high_error_rate/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/elb/high_error_rate/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/elb/high_error_rate/#check-configuration","title":"Check Configuration","text":"<ul> <li>period: 300 (seconds)</li> <li>threshold: 5 (error rate percentage)</li> </ul>"},{"location":"plugins/elb/high_error_rate/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/elb/inactive_load_balancers/","title":"Inactive Load Balancers","text":""},{"location":"plugins/elb/inactive_load_balancers/#overview","title":"Overview","text":"<p>The Inactive Load Balancers check identifies load balancers that are inactive.</p>"},{"location":"plugins/elb/inactive_load_balancers/#key-features","title":"Key Features","text":"<ul> <li>AWS ELB Integration: Fetches and processes data from AWS ELB.</li> <li>Inactive Resource Identification: Identifies load balancers that are inactive.</li> <li>Cost Savings Recommendations: Recommends decommissioning inactive load balancers to save costs.</li> </ul>"},{"location":"plugins/elb/inactive_load_balancers/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/elb/inactive_load_balancers/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/elb/inactive_load_balancers/#check-configuration","title":"Check Configuration","text":"<ul> <li>period: 86400 (seconds)</li> <li>inactive_threshold: 30 (days)</li> </ul>"},{"location":"plugins/elb/inactive_load_balancers/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/elb/low_request_counts/","title":"Low Request Count Load Balancers","text":""},{"location":"plugins/elb/low_request_counts/#overview","title":"Overview","text":"<p>The Low Request Count Load Balancers check identifies load balancers with low request counts.</p>"},{"location":"plugins/elb/low_request_counts/#key-features","title":"Key Features","text":"<ul> <li>AWS ELB Integration: Fetches and processes data from AWS ELB.</li> <li>Request Count Analysis: Identifies load balancers with low request counts.</li> <li>Performance Insights: Provides detailed analysis on performance metrics.</li> </ul>"},{"location":"plugins/elb/low_request_counts/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/elb/low_request_counts/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/elb/low_request_counts/#check-configuration","title":"Check Configuration","text":"<ul> <li>period: 300 (seconds)</li> <li>request_threshold: 100 (requests)</li> </ul>"},{"location":"plugins/elb/low_request_counts/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/elb/no_healthy_targets/","title":"Inactive Load Balancers","text":""},{"location":"plugins/elb/no_healthy_targets/#overview","title":"Overview","text":"<p>The No Healthy Targets check identifies elbs where all targets are unhealthy. </p>"},{"location":"plugins/elb/no_healthy_targets/#key-features","title":"Key Features","text":"<ul> <li>AWS ELB Integration: Fetches and processes data from AWS ELB.</li> <li>Inactive Resource Identification: Identifies load balancers that have no healthy targets.</li> <li>Cost Savings Recommendations: Recommends decommissioning inactive load balancers to save costs.</li> </ul>"},{"location":"plugins/elb/no_healthy_targets/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/elb/no_healthy_targets/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/elb/no_healthy_targets/#check-configuration","title":"Check Configuration","text":"<ul> <li>period: 86400 (seconds)</li> <li>inactive_threshold: 30 (days)</li> </ul>"},{"location":"plugins/elb/no_healthy_targets/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/iam/console_access/","title":"Console Access IAM Plugin","text":""},{"location":"plugins/iam/console_access/#overview","title":"Overview","text":"<p>The Console Access IAM Plugin identifies IAM users with console access enabled, helping to enhance security by ensuring only necessary users have console access.</p>"},{"location":"plugins/iam/console_access/#key-features","title":"Key Features","text":"<ul> <li>AWS IAM Integration: Fetches and processes data from AWS IAM.</li> <li>Security Recommendations: Identifies IAM users with console access to improve security.</li> <li>Detailed Analysis: Provides detailed information on IAM users with console access.</li> </ul>"},{"location":"plugins/iam/console_access/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/iam/console_access/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/iam/console_access/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/iam/mfa_enabled/","title":"IAM Users Without MFA Plugin","text":""},{"location":"plugins/iam/mfa_enabled/#overview","title":"Overview","text":"<p>The IAM Users Without MFA Plugin identifies IAM users who do not have Multi-Factor Authentication (MFA) enabled, helping to enhance security by ensuring all users have MFA enabled.</p>"},{"location":"plugins/iam/mfa_enabled/#key-features","title":"Key Features","text":"<ul> <li>AWS IAM Integration: Fetches and processes data from AWS IAM.</li> <li>Security Recommendations: Identifies IAM users without MFA to improve security.</li> <li>Detailed Analysis: Provides detailed information on IAM users without MFA.</li> </ul>"},{"location":"plugins/iam/mfa_enabled/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/iam/mfa_enabled/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/iam/mfa_enabled/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/iam/overdue_api_keys/","title":"Overdue API Keys Plugin","text":""},{"location":"plugins/iam/overdue_api_keys/#overview","title":"Overview","text":"<p>The Overdue API Keys Plugin identifies IAM API keys that are overdue, helping to enhance security by ensuring all API keys are rotated regularly.</p>"},{"location":"plugins/iam/overdue_api_keys/#key-features","title":"Key Features","text":"<ul> <li>AWS IAM Integration: Fetches and processes data from AWS IAM.</li> <li>Security Recommendations: Identifies overdue API keys to improve security.</li> <li>Detailed Analysis: Provides detailed information on overdue API keys.</li> </ul>"},{"location":"plugins/iam/overdue_api_keys/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/iam/overdue_api_keys/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/iam/overdue_api_keys/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>rotation_threshold_days: The threshold for API key rotation (in days). Default: 90.</li> </ul>"},{"location":"plugins/iam/overdue_api_keys/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/iam/unused_policies/","title":"Unused IAM Policies Plugin","text":""},{"location":"plugins/iam/unused_policies/#overview","title":"Overview","text":"<p>The Unused IAM Policies Plugin identifies IAM policies with zero attachments, helping to optimize IAM policy management by identifying policies that can be deleted or reviewed.</p>"},{"location":"plugins/iam/unused_policies/#key-features","title":"Key Features","text":"<ul> <li>AWS IAM Integration: Fetches and processes data from AWS IAM.</li> <li>Optimization Recommendations: Identifies unused IAM policies to optimize policy management.</li> <li>Detailed Analysis: Provides detailed information on IAM policies with zero attachments.</li> </ul>"},{"location":"plugins/iam/unused_policies/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/iam/unused_policies/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/iam/unused_policies/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/outputs/azure/","title":"opsbox-azure-output","text":"<p>Here is the document for the AzureOutput plugin in the requested format:</p>"},{"location":"plugins/outputs/azure/#azureoutput-plugin","title":"AzureOutput Plugin","text":""},{"location":"plugins/outputs/azure/#overview","title":"Overview","text":"<p>The AzureOutput Plugin processes and creates Azure DevOps ticket issues based on the results of checks, helping to manage and track cost-saving recommendations and other tasks.</p> <p>Description creation requires LLM</p>"},{"location":"plugins/outputs/azure/#key-features","title":"Key Features","text":"<ul> <li>Azure DevOps Integration: Fetches and processes data from Azure DevOps.</li> <li>Issue Creation: Creates detailed Azure DevOps issues based on the provided results.</li> <li>Customizable Priority and Tags: Allows setting priority and tags for the created issues.</li> </ul>"},{"location":"plugins/outputs/azure/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/azure/#azure-devops-configuration","title":"Azure DevOps Configuration","text":"<ul> <li>azure_devops_token: The personal access token for Azure DevOps.</li> <li>azure_devops_organization: The name of the Azure DevOps organization.</li> <li>azure_devops_project: The name of the Azure DevOps project.</li> <li>azure_devops_username: The username for Azure DevOps.</li> <li>azure_devops_priority: The priority of the work item (default: 4).</li> <li>tags: The tags to apply to the work item (optional).</li> <li>create_description: Whether to create a description instead of an issue (default: false).</li> </ul>"},{"location":"plugins/outputs/azure/#example-configuration","title":"Example Configuration","text":"<pre><code>azure_devops_token: your_azure_devops_token\nazure_devops_organization: your_azure_devops_organization\nazure_devops_project: your_azure_devops_project\nazure_devops_username: your_azure_devops_username\nazure_devops_priority: 4\ntags: your_tags\ncreate_description: false\n</code></pre>"},{"location":"plugins/outputs/cli/","title":"CLIOutput Plugin","text":""},{"location":"plugins/outputs/cli/#overview","title":"Overview","text":"<p>The CLIOutput Plugin processes and displays results directly in the command line interface (CLI), providing immediate feedback and insights based on the results of checks.</p>"},{"location":"plugins/outputs/cli/#key-features","title":"Key Features","text":"<ul> <li>Immediate Feedback: Displays results directly in the CLI.</li> <li>Simple Integration: Easily integrates with existing workflows.</li> <li>Detailed Logging: Provides detailed logs of the results.</li> </ul>"},{"location":"plugins/outputs/cli/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/cli/#cli-configuration","title":"CLI Configuration","text":"<p>This plugin does not require any specific configuration parameters.</p>"},{"location":"plugins/outputs/cli/#example-configuration","title":"Example Configuration","text":"<p>No configuration is needed for the CLIOutput plugin.</p>"},{"location":"plugins/outputs/email/","title":"EmailOutput Plugin","text":""},{"location":"plugins/outputs/email/#overview","title":"Overview","text":"<p>The EmailOutput Plugin processes and creates emails based on the results of checks, allowing for easy communication and reporting of findings.</p>"},{"location":"plugins/outputs/email/#key-features","title":"Key Features","text":"<ul> <li>Email Integration: Sends results via email.</li> <li>Customizable SMTP Settings: Allows specifying SMTP server details.</li> </ul>"},{"location":"plugins/outputs/email/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/email/#email-configuration","title":"Email Configuration","text":"<ul> <li>smtp_username: The username for the SMTP server.</li> <li>smtp_password: The password for the SMTP server.</li> <li>smtp_server: The SMTP server to use.</li> <li>smtp_port: The port to use for the SMTP server.</li> <li>receiver_email_list: A comma-separated list of email addresses to send the email to.</li> </ul>"},{"location":"plugins/outputs/email/#example-configuration","title":"Example Configuration","text":"<pre><code>smtp_username: your_smtp_username\nsmtp_password: your_smtp_password\nsmtp_server: your_smtp_server\nsmtp_port: your_smtp_port\nreceiver_email_list: your_receiver_email_list\n</code></pre>"},{"location":"plugins/outputs/github/","title":"GithubOutput Plugin","text":""},{"location":"plugins/outputs/github/#overview","title":"Overview","text":"<p>The GithubOutput Plugin processes and creates GitHub ticket issues based on the results of checks, helping to manage and track cost-saving recommendations and other tasks.</p> <p>Description creation requires LLM</p>"},{"location":"plugins/outputs/github/#key-features","title":"Key Features","text":"<ul> <li>GitHub Integration: Fetches and processes data from GitHub.</li> <li>Issue Creation: Creates detailed GitHub issues based on the provided results.</li> <li>Customizable Labels: Allows setting labels for the created issues.</li> </ul>"},{"location":"plugins/outputs/github/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/github/#github-configuration","title":"GitHub Configuration","text":"<ul> <li>github_token: The token for the GitHub user.</li> <li>repo_owner: The owner of the repository.</li> <li>repo_name: The name of the repository.</li> <li>labels: The labels to apply to the issue (optional).</li> <li>create_description: Whether to create a description instead of an issue (default: false).</li> </ul>"},{"location":"plugins/outputs/github/#example-configuration","title":"Example Configuration","text":"<pre><code>github_token: your_github_token\nrepo_owner: your_repo_owner\nrepo_name: your_repo_name\nlabels: your_labels\ncreate_description: false\n</code></pre>"},{"location":"plugins/outputs/jira/","title":"JiraOutput Plugin","text":""},{"location":"plugins/outputs/jira/#overview","title":"Overview","text":"<p>The JiraOutput Plugin processes and creates Jira issues based on the results of checks, helping to manage and track cost-saving recommendations and other tasks.</p> <p>Requires LLM</p>"},{"location":"plugins/outputs/jira/#key-features","title":"Key Features","text":"<ul> <li>Jira Integration: Fetches and processes data from Jira.</li> <li>Issue Creation: Creates detailed Jira issues based on the provided results.</li> <li>Customizable Project Key: Allows specifying the Jira project to create issues in.</li> </ul>"},{"location":"plugins/outputs/jira/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/jira/#jira-configuration","title":"Jira Configuration","text":"<ul> <li>jira_url: The URL of the Jira instance.</li> <li>jira_email: The email to authenticate to Jira with.</li> <li>jira_api_token: The API key to authenticate to Jira with.</li> <li>jira_project_key: The Jira project to create issues in.</li> </ul>"},{"location":"plugins/outputs/jira/#example-configuration","title":"Example Configuration","text":"<pre><code>jira_url: your_jira_url\njira_email: your_jira_email\njira_api_token: your_jira_api_token\njira_project_key: your_jira_project_key\n</code></pre>"},{"location":"plugins/outputs/json/","title":"TextFileOutput Plugin","text":""},{"location":"plugins/outputs/json/#overview","title":"Overview","text":"<p>The JSONFileOutput Plugin writes the results of checks to json files, allowing for easy storage and review of the output data.</p>"},{"location":"plugins/outputs/json/#key-features","title":"Key Features","text":"<ul> <li>File Output: Writes results to json files.</li> <li>Customizable Output Folder: Allows specifying the folder where the results will be saved.</li> <li>Detailed Logging: Provides detailed logs of the results.</li> </ul>"},{"location":"plugins/outputs/json/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/json/#text-file-configuration","title":"Text File Configuration","text":"<ul> <li>output_folder: The folder to output the results to (default: <code>./findings/</code>).</li> </ul>"},{"location":"plugins/outputs/json/#example-configuration","title":"Example Configuration","text":"<pre><code>output_folder: ./findings/\n</code></pre>"},{"location":"plugins/outputs/pagerduty/","title":"PagerDutyOutput Plugin","text":""},{"location":"plugins/outputs/pagerduty/#overview","title":"Overview","text":"<p>The PagerDutyOutput Plugin processes and sends results to PagerDuty, allowing for incident creation and management based on the findings.</p> <p>LLM required for description creation</p>"},{"location":"plugins/outputs/pagerduty/#key-features","title":"Key Features","text":"<ul> <li>PagerDuty Integration: Sends results to PagerDuty.</li> <li>Customizable Incident Creation: Allows specifying whether to create a description or an issue.</li> </ul>"},{"location":"plugins/outputs/pagerduty/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/pagerduty/#pagerduty-configuration","title":"PagerDuty Configuration","text":"<ul> <li>routing_key: The routing key to use.</li> <li>create_description: Whether to create a description instead of an issue.</li> </ul>"},{"location":"plugins/outputs/pagerduty/#example-configuration","title":"Example Configuration","text":"<pre><code>routing_key: your_routing_key\ncreate_description: true\n</code></pre>"},{"location":"plugins/outputs/slack/","title":"SlackOutput Plugin","text":""},{"location":"plugins/outputs/slack/#overview","title":"Overview","text":"<p>The SlackOutput Plugin processes and sends results to a specified Slack channel, allowing for easy communication and reporting of findings.</p>"},{"location":"plugins/outputs/slack/#key-features","title":"Key Features","text":"<ul> <li>Slack Integration: Sends results to a Slack channel.</li> <li>Customizable Slack Settings: Allows specifying Slack token and channel.</li> </ul>"},{"location":"plugins/outputs/slack/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/slack/#slack-configuration","title":"Slack Configuration","text":"<ul> <li>slack_token: The Slack token to use.</li> <li>slack_channel: The Slack channel to send the message to.</li> </ul>"},{"location":"plugins/outputs/slack/#example-configuration","title":"Example Configuration","text":"<pre><code>slack_token: your_slack_token\nslack_channel: your_slack_channel\n</code></pre>"},{"location":"plugins/outputs/text/","title":"TextFileOutput Plugin","text":""},{"location":"plugins/outputs/text/#overview","title":"Overview","text":"<p>The TextFileOutput Plugin writes the results of checks to text files, allowing for easy storage and review of the output data.</p>"},{"location":"plugins/outputs/text/#key-features","title":"Key Features","text":"<ul> <li>File Output: Writes results to text files.</li> <li>Customizable Output Folder: Allows specifying the folder where the results will be saved.</li> <li>Detailed Logging: Provides detailed logs of the results.</li> </ul>"},{"location":"plugins/outputs/text/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/outputs/text/#text-file-configuration","title":"Text File Configuration","text":"<ul> <li>output_folder: The folder to output the results to (default: <code>./findings/</code>).</li> </ul>"},{"location":"plugins/outputs/text/#example-configuration","title":"Example Configuration","text":"<pre><code>output_folder: ./findings/\n</code></pre>"},{"location":"plugins/r53/empty_zones/","title":"Empty Route 53 Hosted Zones Plugin","text":""},{"location":"plugins/r53/empty_zones/#overview","title":"Overview","text":"<p>The Empty Route 53 Hosted Zones Plugin identifies Route 53 hosted zones with no DNS records, helping to optimize DNS management by identifying zones that can be deleted or reviewed.</p>"},{"location":"plugins/r53/empty_zones/#key-features","title":"Key Features","text":"<ul> <li>AWS Route 53 Integration: Fetches and processes data from AWS Route 53.</li> <li>Detailed Analysis: Provides detailed information on Route 53 hosted zones with no DNS records.</li> <li>Empty Zone Identification: Identifies empty hosted zones to optimize DNS management.</li> </ul>"},{"location":"plugins/r53/empty_zones/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/r53/empty_zones/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/r53/empty_zones/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/rds/empty_storage/","title":"Empty Storage Plugin","text":""},{"location":"plugins/rds/empty_storage/#overview","title":"Overview","text":"<p>The Empty Storage Plugin identifies RDS instances with empty storage, helping to optimize storage usage and reduce costs by identifying instances that can be resized or terminated.</p>"},{"location":"plugins/rds/empty_storage/#key-features","title":"Key Features","text":"<ul> <li>AWS RDS Integration: Fetches and processes data from AWS RDS.</li> <li>Cost Savings Recommendations: Identifies RDS instances with empty storage that can be resized or terminated to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/rds/empty_storage/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/rds/empty_storage/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/rds/empty_storage/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>storage_threshold: The storage threshold (in %) that will count as unutilized (default is 40)</li> </ul>"},{"location":"plugins/rds/empty_storage/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/rds/old_snapshots/","title":"Old Snapshots Plugin","text":""},{"location":"plugins/rds/old_snapshots/#overview","title":"Overview","text":"<p>The Old Snapshots Plugin identifies old RDS snapshots that are no longer needed, helping to reduce storage costs by deleting outdated snapshots.</p>"},{"location":"plugins/rds/old_snapshots/#key-features","title":"Key Features","text":"<ul> <li>AWS RDS Integration: Fetches and processes data from AWS RDS.</li> <li>Cost Savings Recommendations: Identifies old snapshots that can be deleted to save storage costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/rds/old_snapshots/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/rds/old_snapshots/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/rds/old_snapshots/#plugin-specific-defaults","title":"Plugin Specific Defaults","text":"<ul> <li>snapshot_age_threshold: The age threshold to consider. Default is 1 year.</li> </ul>"},{"location":"plugins/rds/old_snapshots/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/rds/rds_idle/","title":"RDS Idle Plugin","text":""},{"location":"plugins/rds/rds_idle/#overview","title":"Overview","text":"<p>The RDS Idle Plugin identifies idle RDS instances, helping to optimize resource usage and reduce costs by identifying instances that can be stopped or terminated.</p>"},{"location":"plugins/rds/rds_idle/#key-features","title":"Key Features","text":"<ul> <li>AWS RDS Integration: Fetches and processes data from AWS RDS.</li> <li>Cost Savings Recommendations: Identifies idle RDS instances that can be stopped or terminated to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/rds/rds_idle/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/rds/rds_idle/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/rds/rds_idle/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>cpu_utilization: CPU utilization threshold for determining idle instances. Default = 5%</li> <li>num_connections: Number of connections threshold for determining idle instances. Default = 100000</li> </ul>"},{"location":"plugins/rds/rds_idle/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/rds/scaling_down/","title":"Scaling Down RDS Instances","text":""},{"location":"plugins/rds/scaling_down/#overview","title":"Overview","text":"<p>Scaling down RDS instances involves reducing the allocated resources (such as CPU, memory, or storage) to better match the current workload. This can help optimize costs and improve resource utilization.</p>"},{"location":"plugins/rds/scaling_down/#key-features","title":"Key Features","text":"<ul> <li>Resource Optimization: Adjusts the instance size to better fit the workload.</li> <li>Cost Savings: Reduces costs by allocating fewer resources.</li> <li>Performance Monitoring: Continuously monitors performance to ensure the instance is appropriately sized.</li> </ul>"},{"location":"plugins/rds/scaling_down/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/rds/scaling_down/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/rds/scaling_down/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>utilization_threshold: The CPU utilization threshold (in percentage) below which an RDS instance is considered underutilized. Default: <code>20</code>.</li> </ul>"},{"location":"plugins/rds/scaling_down/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/s3/object_last_modified/","title":"Object Last Modified Plugin","text":""},{"location":"plugins/s3/object_last_modified/#overview","title":"Overview","text":"<p>The Object Last Modified Plugin identifies S3 objects that have not been modified for a specified period, helping to optimize storage costs by identifying objects that can be deleted or archived.</p>"},{"location":"plugins/s3/object_last_modified/#key-features","title":"Key Features","text":"<ul> <li>AWS S3 Integration: Fetches and processes data from AWS S3.</li> <li>Cost Savings Recommendations: Identifies objects that can be deleted or archived to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/s3/object_last_modified/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/s3/object_last_modified/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/s3/object_last_modified/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>modified_period: The period of inactivity (in days) to consider an object as not modified. Default: <code>90</code>.</li> <li>percent_standard: The threshold for how many items can be in standard storage class when considered unmodified</li> </ul>"},{"location":"plugins/s3/object_last_modified/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/s3/storage_class_usage/","title":"Storage Class Usage Plugin","text":""},{"location":"plugins/s3/storage_class_usage/#overview","title":"Overview","text":"<p>The Storage Class Usage Plugin identifies S3 buckets using specific storage classes (e.g., GLACIER, STANDARD), helping to optimize storage costs by recommending appropriate storage classes based on usage patterns.</p>"},{"location":"plugins/s3/storage_class_usage/#key-features","title":"Key Features","text":"<ul> <li>AWS S3 Integration: Fetches and processes data from AWS S3.</li> <li>Cost Savings Recommendations: Identifies buckets that can benefit from different storage classes to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/s3/storage_class_usage/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/s3/storage_class_usage/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/s3/storage_class_usage/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>storage_classes: List of storage classes to check. Default: <code>[\"GLACIER\", \"STANDARD\"]</code>.</li> </ul>"},{"location":"plugins/s3/storage_class_usage/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"},{"location":"plugins/s3/unused_buckets/","title":"Unused Buckets Plugin","text":""},{"location":"plugins/s3/unused_buckets/#overview","title":"Overview","text":"<p>The Unused Buckets Plugin identifies S3 buckets that have not been accessed or modified for a specified period, helping to optimize storage costs by identifying buckets that can be deleted or archived.</p>"},{"location":"plugins/s3/unused_buckets/#key-features","title":"Key Features","text":"<ul> <li>AWS S3 Integration: Fetches and processes data from AWS S3.</li> <li>Cost Savings Recommendations: Identifies unused buckets that can be deleted or archived to save costs.</li> <li>Performance and Security Insights: Provides detailed analysis on performance and security metrics.</li> </ul>"},{"location":"plugins/s3/unused_buckets/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"plugins/s3/unused_buckets/#aws-configuration","title":"AWS Configuration","text":"<ul> <li>aws_access_key_id: AWS access key ID.</li> <li>aws_secret_access_key: AWS secret access key.</li> <li>aws_region: AWS region.</li> </ul>"},{"location":"plugins/s3/unused_buckets/#plugin-specific-configuration","title":"Plugin Specific Configuration","text":"<ul> <li>unused_period: The period of inactivity to consider a bucket as unused. Default: 1 year.</li> </ul>"},{"location":"plugins/s3/unused_buckets/#example-configuration","title":"Example Configuration","text":"<pre><code>aws_access_key_id: your_access_key_id\naws_secret_access_key: your_secret_access_key\naws_region: your_aws_region\n</code></pre>"}]}